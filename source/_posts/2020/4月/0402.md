---
title: 知识点
date: 2020-04-02 18:00:00
tags: js
---

## js 为什么是单线程？

线程：是操作系统能够进行运算调度的最小单位。
单线程：（上面有说：一条线程指的是进程中一个单一顺序的控制流）就是在进程中只有一条线程，在程序执行时，所走的程序路径按照连续顺序排下来，前面的必须处理好，后面的才会执行。
作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？
所以，为了避免复杂性，从一诞生，JavaScript就是单线程。

## 浏览器的内核机制

浏览器的内核是多线程的，一个浏览器一般至少实现三个常驻线程：

1. javascript引擎：是基于事件驱动单线程执行的，js引擎一直等待着任务队列中任务的到来，然后加以处理，浏览器无论什么时候都只有一个js线程在运行js程序。
2. GUI 渲染线程：负责渲染浏览界面，当界面需要重排、重绘或由于某种操作引发回流时，该线程就会执行。但需要注意 GUI 渲染线程与 js 引擎是互斥的，当js引擎执行时GUI线程会被挂起，
GUI 更新会被保存在一个队列中等到js引擎空闲时立即被执行。
3. 事件触发线程：当一个事件被触发时该线程会把事件添加到待处理列的队尾，等待js引擎的处理。

## React 事件与 js 事件的区别

JSX 上写的事件并没有绑定在对应的真实 DOM 上，而是通过事件代理的方式，将所有的事件都统一绑定在了 document 上。这样的方式不仅减少了内存消耗，还能在组件挂载销毁时统一订阅和移除事件。
另外冒泡到 document 上的事件也不是原生浏览器事件，而是 React 自己实现的合成事件（SyntheticEvent）。因此我们如果不想要事件冒泡的话，调用 event.stopPropagation 是无效的，而应该调用 event.preventDefault。

那么实现合成事件的目的是什么呢？总的来说在我看来好处有两点，分别是：

* 合成事件首先抹平了浏览器之间的兼容问题，另外这是一个跨浏览器原生事件包装器，赋予了跨浏览器开发的能力

* 对于原生浏览器事件来说，浏览器会给监听器创建一个事件对象。如果你有很多的事件监听，那么就需要分配很多的事件对象，造成高额的内存分配问题。但是对于合成事件来说，有一个事件池专门来管理它们的创建和销毁，当事件需要被使用时，就会从池子中复用对象，事件回调结束后，就会销毁事件对象上的属性，从而便于下次复用事件对象。

## setState 的执行流程

## EventLoop

## 移动端适配

移动端的屏幕宽度差距比较小（4-8英寸），UI页面通常也会保持一致的布局方式，只是文字、图标、大图片等可能会根据业务需要做一些定制化的处理。

**Pad设备虽然也是移动设备，但是因为屏幕足够宽，所以现在多数产品（某宝）的方案都是访问PC站点了**

### 移动端多屏适配的需求，常见主要有两类：

1. 布局伸缩式（布局伸缩，内容大小固定或梯级变化）
2. 等比缩放式（布局和内容完全等比例缩放）

#### 布局伸缩式

布局伸缩式适配需求，常见于排版比较简单的信息流展示类业务。
其布局特点一般为横向伸缩，竖向高度固定或由内容填充决定；文字图标等网页内容一般会固定大小，且在宽屏窄屏上的视觉大小保持一致。

##### 技术方案

* 设置 viewport 宽度为 device-width，以保证 px 为单位取值的一些文字图标等网页内容视觉大小符合预期且宽窄屏大小一致。（ css 中的 px 取值需按一倍屏的 UI 稿来写）。
* 布局方案灵活使用相对单位 %/float/flex 等，以保证布局的横向伸缩和容器内各元素的大小间距符合预期；
* 组合包裹相关元素，并相对某一方向做定位，以保证宽度变化时的定位稳定。

#### 等比缩放式

等比缩放式适配需求，广泛应用于各种产品类、运营类等业务场景。
其布局特点简单粗暴，就是根据屏幕宽度整个页面等比缩放。

###### rem

rem 是 css3 新增的相对于根元素 html 的 font-size 计算值的大小的倍数单位。

* 设置 viewport 宽度为 device-width 或其他固定值，以得到 px 为单位的文字、图标或边线等效果
* css 单位使用 rem，js 根据 viewport 宽度以及 css 中的 rem的换算系数，动态计算并设置 html 根节点 font-size，以实现整个页面内容的等比例缩放。

> rem 为基础的动态适配方案
> 设：横向满屏的 rem 个数预定为 remCount，标注稿总宽度 px 为 uiWidth，标注稿内某元素宽度为 uiEleWidth。
> 那么：
> ● 设计稿中 1rem 表示的 px 数 uiPX1rem = uiWidth/remCount
> ● CSS 中某元素 rem 的值 cssEleWidth= uiEleWidth/uiPX1rem
> ● JS 中根节点的 fontSize = document.documentElement.clientWidth/remCount

github 中近 1 万 star 的 js 库lib-flexible 便是采用的此方案。

###### viewport units

1vw 即表示当前视口宽度的 1%，我们可以利用这一点替代“rem+根节点 font-size”的等比缩放实现。
举个例子，750px 的 UI 稿中，宽度 75px 的按钮，在 css 中的宽度描述即为：width:10vw。

###### viewport meta only

## h5与原生如何交互

1. app调用h5的代码

因为app是宿主，可以直接访问h5，所以这种调用比较简单，就是在h5中暴露一些全局对象（包括方法），然后在原生app中调用这些对象。

2. h5调用app的代码

* 由app向h5注入一个全局的js对象，然后在h5直接访问这个对象
* 由h5发起一个自定义协议请求，app拦截这个请求后，再由app调用h5中的回调函数

## 什么是 “React Fiber”？

Fiber 是 React 16 中新的协调引擎。它的主要目的是使 Virtual DOM 可以进行增量式渲染。

## HOC 是什么？相比 mixins 有什么优点？

React 的思想中是存在函数式编程的，高阶组件和高阶函数就是同一个东西。我们实现一个函数，传入一个组件，然后在函数内部再实现一个函数去扩展传入的组件，最后返回一个新的组件，这就是高阶组件的概念，作用就是为了更好的复用代码。

其实 HOC 和 Vue 中的 mixins 作用是一致的，并且在早期 React 也是使用 mixins 的方式。但是在使用 class 的方式创建组件以后，mixins 的方式就不能使用了，并且其实 mixins 也是存在一些问题的，比如：

* 隐含了一些依赖，比如我在组件中写了某个 state 并且在 mixin 中使用了，就这存在了一个依赖关系。万一下次别人要移除它，就得去 mixin 中查找依赖
* 多个 mixin 中可能存在相同命名的函数，同时代码组件中也不能出现相同命名的函数，否则就是重写了，其实我一直觉得命名真的是一件麻烦事。
* 雪球效应，虽然我一个组件还是使用着同一个 mixin，但是一个 mixin 会被多个组件使用，可能会存在需求使得 mixin 修改原本的函数或者新增更多的函数，这样可能就会产生一个维护成本

HOC 解决了这些问题，并且它们达成的效果也是一致的，同时也更加的政治正确（毕竟更加函数式了）。

## 什么是作用域链?

当代码在一个环境中执行时，会创建变量对象的一个作用域链。

**什么是作用域**

变量的作用域分为两种：全局变量和局部变量。
1、全局作用域： 最外层函数定义的变量拥有全局作用域，即对任何内部函数来说，都是可以访问的；
2、局部作用域： 局部作用域一般只在固定的代码片段内可访问到，而对于函数外部是无法访问的，最常见的例如函数内部。

## webpack 优化, webpack4 与 webpack3 的区别

1. mode

webpack4 新增了mode配置，只有两种值 development | production。

2. CommonsChunkPlugin

webpack.optimize.CommonsChunkPlugin 已经从 webpack4 移除。 可使用 optimization.splitChunks 进行模块划分（提取公用代码）。

3. mini-css-extract-plugin（css文件提取）

移除了 extract-text-webpack-plugin 配置，增加 mini-css-extract-plugin 配置。

4. babel 使用新的命名空间 @babel

5. UglifyJsPlugin

移除 UglifyJsPlugin，采用 TerserPlugin。

6. 移除 loaders，必须使用 rules

webpack4之前，loaders 跟 rulrs 是可以一起使用的。

7. 支持 es6 方式引入文件

import a from 'a.js';

8. 升级 Happypack 插件进行多线程加速打包
