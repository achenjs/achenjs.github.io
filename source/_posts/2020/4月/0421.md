---
title: 知识点
date: 2020-04-21 14:00:00
tags: js
---

#### img的src也可以跨域吗

原理上都是利用标签的src可绕过同源限制，跨域请求的特点，

硬要说不同，那么区别在于：img只能单向发送get请求，不可访问响应内容（只是展现），而script可对其进行解析

#### 实现斐波那契数列并利用缓存进行优化

#### redux中connect()的作用

连接 React 组件与 Store 的作用。

#### redux-saga的作用

#### http中的option方法的应用场景

OPTIONS方法请求web服务器告知其支持的各种功能。可以询问服务器通常支持哪些方法，或者对某些特殊资源支持哪些方法。

#### 前端预检的过程

一、为什么要发预检请求？

出于安全考虑，浏览器会限制从脚本发起的跨域 http 请求，像 XMLHttpRequest 和 Fetch 都遵循同源策略。
浏览器限制跨域请求一般有两种方式：

1. 浏览器限制发起跨域请求
2. 跨域请求跨域正常发起，但是返回的结果被浏览器拦截

一般浏览器都是第二种方式限制跨域请求，那就是说请求已到达服务器，并有可能对数据库里的数据进行了操作，但是返回的结果被浏览器拦截了，那么我们就获取不到返回结果，这是一次失败的请求，但是可能对数据库里的数据产生了影响。

为了防止这种情况的发生，规范要求，对这种可能对服务器数据产生副作用的HTTP请求方法，浏览器必须先使用OPTIONS方法发起一个预检请求，从而获知服务器是否允许该跨域请求：如果允许，就发送带数据的真实请求；如果不允许，则阻止发送带数据的真实请求。

二、什么时候发预检请求

http请求包括：简单请求 和 复杂请求。

1. 简单请求

简单请求不会触发 CORS 预检请求。
若满足以下条件，则可视为“简单请求”：

* get
* head
* post

仅当 post 方法的 Content-Type 值等于下列之一才算简单请求
> text-plain
> multipart/form-data
> application/x-www-form-unlenceded

2. 复杂请求（需预检的请求）

“需预检的请求”要求必须首先使用OPTIONS方法发起一个预检请求到服务区，以获知服务器是否允许该实际请求。“预检请求”的使用，可以避免跨域请求对服务器的用户数据产生未预期的影响。

当请求满足下述任一条件时，即应首先发送预检请求：
使用了下面任一 HTTP 方法：

* put
* delete
* connect
* options
* trace
* patch

#### 移动端怎么解决12px字体的问题，怎么解决0.5px的线条

#### 移动端手指触碰后的事件api触发顺序

#### react 的虚拟 dom 是怎么实现的

#### react 的渲染过程中，兄弟节点之间是怎么处理的？也就是 key 值不一样的时候。

#### 你说一下 webpack 的一些 plugin，怎么使用 webpack 对项目进行优化

#### scoped是怎么实现的，追问为什么加deep能穿透样式？（可以说说 :global 的实现）

#### 为什么字体大小最小设置成12px？

因为 Chrome 这款任性的浏览器做了如下限制：

1. font-size 有一个最小值 12px（不同操作系统、不同语言可能限制不一样），低于12px的，一律按12px显示。理由是 Chrome 认为低于12px的中文对人类是不友好的。
2. 但是允许你把 font-size 设置为0
3. 这个12px的限制用户是可以自行调整的，进入 chrome://setting/fonts 设置。

如果一定要使用小于12px的字号，可以使用 transform: scale(0.9), 缩放的方式来解决。

Mac 下测试 Chrome、Firefox、Safire 浏览器，只有 Chrome 有这个限制。

##### 我现在有一个数组[1,2,3,4]，请实现算法，得到这个数组的全排列的数组，如[2,1,3,4]，

#### 时间复杂度

#### 我现在有一个背包，容量为 m，然后有 n 个货物，重量分别为 w1,w2,w3…wn，每个货物的价值是 v1,v2,v3…vn，w 和 v 没有任何关系，请求背包能装下的最大价值。

#### JS手写二分搜索算法

#### 实现一个Lazyman
