<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>%2F2020%2F05%2F13%2F2020%2F5%E6%9C%88%2Ftest%2F</url>
    <content type="text"><![CDATA[Document * { margin: 0; } .wrapper { height: 300px; } .left, .right { width: 300px; } .left { float: left; background: red; } .right { float: right; background: #000; } .content { background: blue; } .box { background: yellow; width: 100px; height: 100px; padding: 10px; border: 1px; } left right neirongneirongneirongneirongneirong console.log(document.querySelector('.box').clientWidth)]]></content>
  </entry>
  <entry>
    <title><![CDATA[知识点]]></title>
    <url>%2F2020%2F04%2F21%2F2020%2F4%E6%9C%88%2F0421%2F</url>
    <content type="text"><![CDATA[img的src也可以跨域吗原理上都是利用标签的src可绕过同源限制，跨域请求的特点， 硬要说不同，那么区别在于：img只能单向发送get请求，不可访问响应内容（只是展现），而script可对其进行解析 实现斐波那契数列并利用缓存进行优化redux中connect()的作用连接 React 组件与 Store 的作用。 redux-saga的作用http中的option方法的应用场景OPTIONS方法请求web服务器告知其支持的各种功能。可以询问服务器通常支持哪些方法，或者对某些特殊资源支持哪些方法。 前端预检的过程一、为什么要发预检请求？ 出于安全考虑，浏览器会限制从脚本发起的跨域 http 请求，像 XMLHttpRequest 和 Fetch 都遵循同源策略。浏览器限制跨域请求一般有两种方式： 浏览器限制发起跨域请求 跨域请求跨域正常发起，但是返回的结果被浏览器拦截 一般浏览器都是第二种方式限制跨域请求，那就是说请求已到达服务器，并有可能对数据库里的数据进行了操作，但是返回的结果被浏览器拦截了，那么我们就获取不到返回结果，这是一次失败的请求，但是可能对数据库里的数据产生了影响。 为了防止这种情况的发生，规范要求，对这种可能对服务器数据产生副作用的HTTP请求方法，浏览器必须先使用OPTIONS方法发起一个预检请求，从而获知服务器是否允许该跨域请求：如果允许，就发送带数据的真实请求；如果不允许，则阻止发送带数据的真实请求。 二、什么时候发预检请求 http请求包括：简单请求 和 复杂请求。 简单请求 简单请求不会触发 CORS 预检请求。若满足以下条件，则可视为“简单请求”： get head post 仅当 post 方法的 Content-Type 值等于下列之一才算简单请求 text-plainmultipart/form-dataapplication/x-www-form-unlenceded 复杂请求（需预检的请求） “需预检的请求”要求必须首先使用OPTIONS方法发起一个预检请求到服务区，以获知服务器是否允许该实际请求。“预检请求”的使用，可以避免跨域请求对服务器的用户数据产生未预期的影响。 当请求满足下述任一条件时，即应首先发送预检请求：使用了下面任一 HTTP 方法： put delete connect options trace patch 移动端怎么解决12px字体的问题，怎么解决0.5px的线条移动端手指触碰后的事件api触发顺序react 的虚拟 dom 是怎么实现的react 的渲染过程中，兄弟节点之间是怎么处理的？也就是 key 值不一样的时候。你说一下 webpack 的一些 plugin，怎么使用 webpack 对项目进行优化scoped是怎么实现的，追问为什么加deep能穿透样式？（可以说说 :global 的实现）为什么字体大小最小设置成12px？因为 Chrome 这款任性的浏览器做了如下限制： font-size 有一个最小值 12px（不同操作系统、不同语言可能限制不一样），低于12px的，一律按12px显示。理由是 Chrome 认为低于12px的中文对人类是不友好的。 但是允许你把 font-size 设置为0 这个12px的限制用户是可以自行调整的，进入 chrome://setting/fonts 设置。 如果一定要使用小于12px的字号，可以使用 transform: scale(0.9), 缩放的方式来解决。 Mac 下测试 Chrome、Firefox、Safire 浏览器，只有 Chrome 有这个限制。 我现在有一个数组[1,2,3,4]，请实现算法，得到这个数组的全排列的数组，如[2,1,3,4]，时间复杂度我现在有一个背包，容量为 m，然后有 n 个货物，重量分别为 w1,w2,w3…wn，每个货物的价值是 v1,v2,v3…vn，w 和 v 没有任何关系，请求背包能装下的最大价值。JS手写二分搜索算法实现一个Lazyman]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[节流、防抖]]></title>
    <url>%2F2020%2F04%2F17%2F2020%2F4%E6%9C%88%2F0417%2F</url>
    <content type="text"><![CDATA[js 防抖和节流在进行窗口的resize、scroll，输入框内容校验等操作时，如果事件处理函数调用的频率无限制，会加重浏览器的负担，导致用户体验非常糟糕。此时我们可以采用debounce（防抖）和throttle（节流）的方式来减少调用频率，同时又不影响实际效果。 函数防抖函数防抖（debounce）：当持续触发事件时，一定时间内没有再触发事件，事件处理函数才会执行一次，如果设定的时间到来之前，又一次触发了时事件，就重新开始延时。 1234567891011function debounce(fn, delay) &#123; let timer = null; return function() &#123; if (timer) &#123; clearTimeout(timer); &#125; timer = setTimeout(fn, delay); &#125;&#125; 函数节流函数节流（throttle）：当持续触发事件时，保证一定时间段内只调用一次事件处理函数。 节流 throttle（时间缀版） 123456789101112function throttle(fn, delay) &#123; let prev = Date.now(); return function() &#123; let now = Date.now(); if (now - prev &gt;= delay) &#123; fn.apply(this, arguments); prev = Date.now(); &#125; &#125;&#125; 节流 throttle（定时器版） 12345678910111213function throttle(fn, delay) &#123; let timer = null; return function() &#123; const _that = this; const args = arguments; if (!timer) &#123; timer = setTimeout(function() &#123; fn.apply(_that, args); timer = null &#125;, delay); &#125; &#125;&#125; 节流 throttle （时间缀+定时器版） 1234567891011121314151617181920function throttle(fn, delay) &#123; let timer = null; let startTime = Date.now(); return function() &#123; let _that = this; let args = arguments; let nowTime = Date.now(); clearTimeout(timer); if (nowTime - startTime &gt;= delay) &#123; fn.apply(_that, args); startTime = Date.now(); &#125; else &#123; timer = setTimeout(fn, delay - (nowTime - startTime)); &#125; &#125;&#125; 总结函数防抖：将几次操作合并为一次操作进行。原理是维护一个计时器，规定在 delay 时间后触发函数，但是在 delay 时间内再次触发的话，就会取消之前的计时器而重新设置。这样一来，只有最后一次操作能被触发。 函数节流：函数节流不管事件触发有多频繁，都会保证在规定时间内一定会执行一次真正的事件处理函数，而函数防抖只是在最后一次事件后才触发一次函数。比如在页面的无限加载场景下，我们需要用户在滚动页面时，每隔一段时间发一次 AJAX 请求，而不是在用户停下滚动页面操作时才去请求数据。这样的场景，就适合用节流技术来实现。]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[知识点]]></title>
    <url>%2F2020%2F04%2F02%2F2020%2F4%E6%9C%88%2F0402%2F</url>
    <content type="text"><![CDATA[js 为什么是单线程？线程：是操作系统能够进行运算调度的最小单位。单线程：（上面有说：一条线程指的是进程中一个单一顺序的控制流）就是在进程中只有一条线程，在程序执行时，所走的程序路径按照连续顺序排下来，前面的必须处理好，后面的才会执行。作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？所以，为了避免复杂性，从一诞生，JavaScript就是单线程。 浏览器的内核机制浏览器的内核是多线程的，一个浏览器一般至少实现三个常驻线程： javascript引擎：是基于事件驱动单线程执行的，js引擎一直等待着任务队列中任务的到来，然后加以处理，浏览器无论什么时候都只有一个js线程在运行js程序。 GUI 渲染线程：负责渲染浏览界面，当界面需要重排、重绘或由于某种操作引发回流时，该线程就会执行。但需要注意 GUI 渲染线程与 js 引擎是互斥的，当js引擎执行时GUI线程会被挂起，GUI 更新会被保存在一个队列中等到js引擎空闲时立即被执行。 事件触发线程：当一个事件被触发时该线程会把事件添加到待处理列的队尾，等待js引擎的处理。 React 事件与 js 事件的区别JSX 上写的事件并没有绑定在对应的真实 DOM 上，而是通过事件代理的方式，将所有的事件都统一绑定在了 document 上。这样的方式不仅减少了内存消耗，还能在组件挂载销毁时统一订阅和移除事件。另外冒泡到 document 上的事件也不是原生浏览器事件，而是 React 自己实现的合成事件（SyntheticEvent）。因此我们如果不想要事件冒泡的话，调用 event.stopPropagation 是无效的，而应该调用 event.preventDefault。 那么实现合成事件的目的是什么呢？总的来说在我看来好处有两点，分别是： 合成事件首先抹平了浏览器之间的兼容问题，另外这是一个跨浏览器原生事件包装器，赋予了跨浏览器开发的能力 对于原生浏览器事件来说，浏览器会给监听器创建一个事件对象。如果你有很多的事件监听，那么就需要分配很多的事件对象，造成高额的内存分配问题。但是对于合成事件来说，有一个事件池专门来管理它们的创建和销毁，当事件需要被使用时，就会从池子中复用对象，事件回调结束后，就会销毁事件对象上的属性，从而便于下次复用事件对象。 setState 的执行流程EventLoop移动端适配移动端的屏幕宽度差距比较小（4-8英寸），UI页面通常也会保持一致的布局方式，只是文字、图标、大图片等可能会根据业务需要做一些定制化的处理。 Pad设备虽然也是移动设备，但是因为屏幕足够宽，所以现在多数产品（某宝）的方案都是访问PC站点了 移动端多屏适配的需求，常见主要有两类： 布局伸缩式（布局伸缩，内容大小固定或梯级变化） 等比缩放式（布局和内容完全等比例缩放） 布局伸缩式布局伸缩式适配需求，常见于排版比较简单的信息流展示类业务。其布局特点一般为横向伸缩，竖向高度固定或由内容填充决定；文字图标等网页内容一般会固定大小，且在宽屏窄屏上的视觉大小保持一致。 技术方案 设置 viewport 宽度为 device-width，以保证 px 为单位取值的一些文字图标等网页内容视觉大小符合预期且宽窄屏大小一致。（ css 中的 px 取值需按一倍屏的 UI 稿来写）。 布局方案灵活使用相对单位 %/float/flex 等，以保证布局的横向伸缩和容器内各元素的大小间距符合预期； 组合包裹相关元素，并相对某一方向做定位，以保证宽度变化时的定位稳定。 等比缩放式等比缩放式适配需求，广泛应用于各种产品类、运营类等业务场景。其布局特点简单粗暴，就是根据屏幕宽度整个页面等比缩放。 remrem 是 css3 新增的相对于根元素 html 的 font-size 计算值的大小的倍数单位。 设置 viewport 宽度为 device-width 或其他固定值，以得到 px 为单位的文字、图标或边线等效果 css 单位使用 rem，js 根据 viewport 宽度以及 css 中的 rem的换算系数，动态计算并设置 html 根节点 font-size，以实现整个页面内容的等比例缩放。 rem 为基础的动态适配方案设：横向满屏的 rem 个数预定为 remCount，标注稿总宽度 px 为 uiWidth，标注稿内某元素宽度为 uiEleWidth。那么：● 设计稿中 1rem 表示的 px 数 uiPX1rem = uiWidth/remCount● CSS 中某元素 rem 的值 cssEleWidth= uiEleWidth/uiPX1rem● JS 中根节点的 fontSize = document.documentElement.clientWidth/remCount github 中近 1 万 star 的 js 库lib-flexible 便是采用的此方案。 viewport units1vw 即表示当前视口宽度的 1%，我们可以利用这一点替代“rem+根节点 font-size”的等比缩放实现。举个例子，750px 的 UI 稿中，宽度 75px 的按钮，在 css 中的宽度描述即为：width:10vw。 viewport meta onlyh5与原生如何交互 app调用h5的代码 因为app是宿主，可以直接访问h5，所以这种调用比较简单，就是在h5中暴露一些全局对象（包括方法），然后在原生app中调用这些对象。 h5调用app的代码 由app向h5注入一个全局的js对象，然后在h5直接访问这个对象 由h5发起一个自定义协议请求，app拦截这个请求后，再由app调用h5中的回调函数 什么是 “React Fiber”？Fiber 是 React 16 中新的协调引擎。它的主要目的是使 Virtual DOM 可以进行增量式渲染。 HOC 是什么？相比 mixins 有什么优点？React 的思想中是存在函数式编程的，高阶组件和高阶函数就是同一个东西。我们实现一个函数，传入一个组件，然后在函数内部再实现一个函数去扩展传入的组件，最后返回一个新的组件，这就是高阶组件的概念，作用就是为了更好的复用代码。 其实 HOC 和 Vue 中的 mixins 作用是一致的，并且在早期 React 也是使用 mixins 的方式。但是在使用 class 的方式创建组件以后，mixins 的方式就不能使用了，并且其实 mixins 也是存在一些问题的，比如： 隐含了一些依赖，比如我在组件中写了某个 state 并且在 mixin 中使用了，就这存在了一个依赖关系。万一下次别人要移除它，就得去 mixin 中查找依赖 多个 mixin 中可能存在相同命名的函数，同时代码组件中也不能出现相同命名的函数，否则就是重写了，其实我一直觉得命名真的是一件麻烦事。 雪球效应，虽然我一个组件还是使用着同一个 mixin，但是一个 mixin 会被多个组件使用，可能会存在需求使得 mixin 修改原本的函数或者新增更多的函数，这样可能就会产生一个维护成本 HOC 解决了这些问题，并且它们达成的效果也是一致的，同时也更加的政治正确（毕竟更加函数式了）。 什么是作用域链?当代码在一个环境中执行时，会创建变量对象的一个作用域链。 什么是作用域 变量的作用域分为两种：全局变量和局部变量。1、全局作用域： 最外层函数定义的变量拥有全局作用域，即对任何内部函数来说，都是可以访问的；2、局部作用域： 局部作用域一般只在固定的代码片段内可访问到，而对于函数外部是无法访问的，最常见的例如函数内部。 webpack 优化, webpack4 与 webpack3 的区别]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络协议]]></title>
    <url>%2F2020%2F04%2F02%2F2020%2F5%E6%9C%88%2F0513%2F</url>
    <content type="text"><![CDATA[https 如何建立连接, TLS 加密方式以及握手的流程HTTPS其实是HTTP + SSL / TLS 两部分组成，也就是在HTTP上又加了一层处理加密信息的模块。服务端和客户端的信息传输都会通过TLS进行加密，所以传输的数据都是加密后的数据。 进行三次握手，建立TCP连接。 第一次握手：建立连接。客户端发送连接请求报文段，将SYN位置为1，Sequence Number为x；然后，客户端进入SYN_SEND状态，等待服务器的确认； 第二次握手：服务器收到SYN报文段。服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认，设置Acknowledgment Number为x+1(Sequence Number+1)；同时，自己还要发送SYN请求信息，将SYN位置为1，Sequence Number为y；服务器端将上述所有信息放到一个报文段（即SYN+ACK报文段）中，一并发送给客户端，此时服务器进入SYN_RECV状态； 第三次握手：客户端收到服务器的SYN+ACK报文段。然后将Acknowledgment Number设置为y+1，向服务器发送ACK报文段，这个报文段发送完毕以后，客户端和服务器端都进入ESTABLISHED状态，完成TCP三次握手。 SSL握手过程 第一阶段 客户端发起请求，以明文传输请求信息，建立安全能力 包括协议版本 会话Id 密码构件 压缩方法和初始随机数 第二阶段 服务器发送证书 密钥交换数据和证书请求，最后发送请求-相应阶段的结束信号 第三阶段 如果有证书请求客户端发送此证书 之后客户端发送密钥交换数据 也可以发送证书验证消息 第四阶段 变更密码构件和结束握手协议]]></content>
      <tags>
        <tag>https</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[知识点]]></title>
    <url>%2F2020%2F03%2F31%2F2020%2F3%E6%9C%88%2F0331%2F</url>
    <content type="text"><![CDATA[React实现一个场景，渲染多张图片，保证图片的底部尽量是对齐的，然后滚动条拉到底，在请求图片再次渲染React 中 key 的用法，常用使用场景key的概念 react 中的 key 属性是一个特殊的属性，它的出现不是给开发者用的，而是给 react 自身用的。简单的来说，react 利用 key 来识别组件，他是一种身份标识，就像每个人的身份证一样。每个 key 对应一个组件，相同的 key, react 会认为是同一个组件，这样后续相同的 key 对应的组件都不会被创建。(经测试，16版本之后key重复也会渲染出来？) key的使用场景 在项目开发中，key属性的使用场景最多的还是由数组动态创建的子组件情况，需要为每个子组件添加唯一的key属性值。那有的人会自然而然想到，key 和动态渲染的子元素获取的index的值很接近，是不是我们可以直接使用index值 赋值给key呢？ 12345&#123; data.map((item, index) =&gt; ( &lt;div key=&#123;index&#125;&gt;item.name&lt;/div&gt; ))&#125; 在尝试后我们发现报错没了，渲染也没问题。但是这里我们强烈不推荐使用数组的index 值来作为key。如果数据更新仅仅是数组重新排序或在其中间位置插入新元素，那么所有元素都将重新渲染。 例如：本来index=2 的元素向前移动后，那该元素的key 不也同样发生了改变，那这样改变，key 就没有任何存在的意义了，既然是作为身份证一样的存在，那就不容有失，当然，在你用key值创建子组件的时候，若数组的内容只是作为纯展示，而不涉及到数组的动态变更，其实是可以使用index 作为key的， key的值必须保证唯一且稳定 我们在与key值打过几次交到以后，感觉key值就类似于数据库中的主键id一样，有且唯一。 React如何处理更新React 内部 setState 是如何批处理的setState 的批量更新按照先进先出的原则，顺序更新。 在 react 的 event handler 内部同步的多次 setState 会被 batch 为一次更新 在一个异步的事件循环里面多次 setState，react 不会 batch 可以使用React.unstable_batchedUpdates 来强制 batch 为什么在 setTimeout 中多次 setState，react 不会 batch？ 因为 React 的更新是基于 Transaction（事务）的，Transacation 就是给目标执行的函数包裹一下，加上前置和后置的 hook （有点类似 koa 的 middleware），在开始执行之前先执行 initialize hook，结束之后再执行 close hook，这样搭配上 isBatchingUpdates 这样的布尔标志位就可以实现一整个函数调用栈内的多次 setState 全部入 pending 队列，结束后统一 apply 了。 但是 setTimeout 这样的方法执行是脱离了事务的，react 管控不到，所以就没法 batch 了。 React没有控制权的函数 setTimeout 为什么 react 要这么设计？ 123456789101112131415161718function Parent() &#123; let [count, setCount] = useState(0); return ( &lt;div onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt; Parent clicked &#123;count&#125; times &lt;Child /&gt; &lt;/div&gt; );&#125;function Child() &#123; let [count, setCount] = useState(0); return ( &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt; Child clicked &#123;count&#125; times &lt;/button&gt; );&#125; 上面这样的 demo，由于点击事件冒泡的缘故，我们假设如果 react 不 batch 立即更新的话，那么点了 child button 之后的逻辑会是如下这样 123456789*** 进入 react click 的事件函数 ***Child (onClick) 触发点击 - setState 修改 state - re-render Child 重新渲染 // 😞 不必要的Parent (onClick) 触发点击（冒泡） - setState 修改 state - re-render Parent 重新渲染 - re-render Child 重新渲染 （渲染是自顶向下的，父亲更新会导致儿子更新）*** 退出 react click 的事件函数 *** 从上面可以看出，第一次子组件的重新渲染完全是浪费的。 所以 React 设计成 setState 不立即触发重新渲染，而是先执行完所有的 event handler，然后用一次重新渲染完成所有更新。 forceUpdate的说明 forceUpdate 从函数名上理解：“强制更新”。 forceUpdate 是同步的吗？“强制”会保证调用然后直接dom-diff吗？ forceUpdate在批量与否的表现上，和setState是一样的。在React有控制权的函数里，是批量的。 “强制”更新整个组件树吗？包括自己，子孙后代组件吗？ forceUpdate只会强制本身组件的更新，即不调用“shouldComponentUpdate”直接更新，对于子孙后代组件还是要调用自己的“shouldComponentUpdate”来决定的。 React15如何去优化useCallback useMemo的区别useMemo 1const memoizedValue = useMemo(() =&gt; computeExpensiveValue(a, b), [a, b]); 把创建函数和依赖项数组作为参数传入useMemo，它仅会在某个依赖项改变时才重新计算memoized值。这种优化有助于避免在每次渲染时都进行高开销的计算。 useCallback 1234const memoizedCallback = useCallback( () =&gt; doSomething(a, b), [a, b]); 把内联回调函数及依赖项数组作为参数传入useCallback, 它将返回该回调函数的 memoized 版本，该回调函数仅在某个依赖项改变时才会更新。当你把回调函数传递给经过优化的并使用引用相等性去避免非必要的渲染的子组件时，它将非常有用 看起来似乎和useMemo差不多，我们来看看有什么异同： useMemo 和 useCallback 接收的参数都是一样，都是在其依赖项发生变化后才执行，都是返回缓存的值，区别在于 useMemo 返回的是函数运行的结果，useCallback返回的函数。 useCallback(fn, deps) 相当于 useMemo(() =&gt; fn, deps) React Hooks没有破坏性改动 完全是可选的。 100%向后兼容的。 现在可用，hook 发布于 v16.8.0 没有计划从React移除class。Hook不会影响你对 React 概念的理解。 动机Hook 解决了我们五年来编写和维护成千上万的组件时遇到的各种各样看起来不相关的问题。 在组件之间复用状态逻辑很难你可以使用 Hook 从组件中提取状态逻辑，使得这些逻辑可以单独测试并复用。Hook 使你在无需修改组件结构的情况下复用状态逻辑。 复杂组件变得难以理解我们经常维护一些组件，组件起初很简单，但是逐渐会被状态逻辑和副作用充斥。每个生命周期常常包含一些不相关的逻辑。例如，组件常常在 componentDidMount 和 componentDidUpdate 中获取数据。但是，同一个 componentDidMount 中可能也包含很多其它的逻辑，如设置事件监听，而之后需在 componentWillUnmount 中清除。相互关联且需要对照修改的代码被进行了拆分，而完全不相关的代码却在同一个方法中组合在一起。如此很容易产生 bug，并且导致逻辑不一致。 为了解决这个问题，Hook 将组件中相互关联的部分拆分成更小的函数（比如设置订阅或请求数据），而并非强制按照生命周期划分。你还可以使用 reducer 来管理组件的内部状态，使其更加可预测。 难以理解的 class除了代码复用和代码管理会遇到困难外，我们还发现 class 是学习 React 的一大屏障。你必须去理解 JavaScript 中 this 的工作方式，这与其他语言存在巨大差异。还不能忘记绑定事件处理器。没有稳定的语法提案，这些代码非常冗余。大家可以很好地理解 props，state 和自顶向下的数据流，但对 class 却一筹莫展。即便在有经验的 React 开发者之间，对于函数组件与 class 组件的差异也存在分歧，甚至还要区分两种组件的使用场景。class 也给目前的工具带来了一些问题。例如，class 不能很好的压缩，并且会使热重载出现不稳定的情况。因此，我们想提供一个使代码更易于优化的 API。 为了解决这些问题，Hook 使你在非 class 的情况下可以使用更多的 React 特性。 从概念上讲，React 组件一直更像是函数。而 Hook 则拥抱了函数，同时也没有牺牲 React 的精神原则。Hook 提供了问题的解决方案，无需学习复杂的函数式或响应式编程技术。 React Context 如何去使用 React.createContext 1const MyContext = React.createContext(null); Context.Provider 1&lt;MyContext.Provider value=&#123;value&#125;&gt; 每个 Context 组件都会返回一个 Provider React组件，它允许消费组件订阅 context 的变化。 Class.contextType 123456789101112131415class Myclass extends React.Component &#123; static contextType = MyContext; componentDidMount() &#123; let value = this.context; &#125; componentDidUpdate() &#123; let value = this.context; &#125; render() &#123; let value = this.context; &#125;&#125; 挂载在class上的 contextType 属性会被重赋值为一个由 React.createContext() 创建的 Context 对象。 这能让你使用this.context 来消费最近 Context 上的值。你可以在任何生命周期中访问到它，包括render函数中。 Context.Consumer 12345&lt;MyContext.Consumer&gt; &#123; value =&gt; /* 基于context的值渲染 */ &#125;&lt;/MyContext.consumer&gt; Redux 和 Mobx 的区别 开发难度低，redux 需要引入很多第三方库来完善工程需求。 开发代码少， redux 需要写大量的样板代码。 增加渲染性能，redux需要借助 shouldComponentUpdate 或者 immutable 来优化。 在使用Redux中，当修改一个数据，发现组件没有更新，可能的原因有哪些 是否 key 值重复导致 是否正确的引入数据, 或者传递props 是否组件内部忘记connect React16 函数式编程怎么去优化 useMemo useCallback fragments]]></content>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[知识点]]></title>
    <url>%2F2020%2F03%2F30%2F2020%2F3%E6%9C%88%2F0330%2F</url>
    <content type="text"><![CDATA[进程和线程的区别CDNCDN 内容分发网络，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络阻塞，提高用户访问响应效率和命中率。CDN 的关键技术有内容存储和分发技术。 打印一个树结构的对象flex布局js函数的4种调用方式 作为函数直接调用 作为对象的方法调用 使用call、apply动态调用 new命令间接调用 this的指向有哪几种情况？ 作为函数直接调用，非严格模式下，this指向window，严格模式下，this指向undefined 作为某对象的方法调用，this指向这个对象 使用apply、call、bind调用，this是第一个传递进去的值 在构造函数中调用，this指向这个新创建的对象 箭头函数中没有this，this在箭头函数创建时确定，它与声明所在的上下文相同。 regexp正则，讲讲贪婪模式正则默认是贪婪模式，默认的贪婪模式会尽可能多的匹配所搜索的字符串。 linux常用命令面向对象和面向过程的区别，以及他们各自的优缺点Css实现瀑布流Css 实现圆形进度条less sass的区别链表和数组的区别js为什么单线程说说 typescript 的特性，有什么好处移动端适配怎么做]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP----HTTP缓存机制]]></title>
    <url>%2F2020%2F03%2F24%2F2020%2F3%E6%9C%88%2F0324-02%2F</url>
    <content type="text"><![CDATA[HTTP—-HTTP缓存机制缓存的规则我们知道http的缓存属于客户端缓存，后面会提到为什么属于客户端缓存。所以我们认为浏览器存在一个缓存数据库，用于储存一些不经常变化的静态文件（图片、css、js等）。我们将缓存分为强制缓存和协商缓存。 强制缓存强缓存中，当请求再次发出时，浏览器会根据其中的 expires 和 cache-control 判断目标资源是否“命中”强缓存，若命中则直接从缓存中获取资源，不会再与服务端发生通信。 命中强缓存的情况下，返回的 HTTP 状态码为 200 （如下图）。 协商缓存又称对比缓存，客户端会先从缓存数据库中获取到一个缓存数据的标识，得到标识后请求服务端验证是否失效，如果没有失效服务端会返回304，此时客户端直接从缓存中获取所以请求的数据，如果标识失效，服务端会返回更新后的数据。 两类缓存机制可以同时存在，强制缓存的优先级高于协商缓存，当执行强制缓存时，如若缓存命中，则直接使用缓存数据库数据，不在进行缓存协商。 缓存的方案强制缓存对于强制缓存，服务器响应的header中会用两个字段来表明 —– Expires和Cache-Control ExpiresExpires的值为服务端返回的数据到期时间。当再次请求时的请求时间小于返回的此时间，则直接使用缓存数据。但由于服务端时间和客户端时间可能有误差，这也就导致缓存命中的误差，另一方面，Expires是HTTP1.0的产物，故现在大多数使用Cache-control替代。 Cache-ControlCache-control有很多属性，不同的属性代表的意义也不同。private：客户端可以缓存public：客户端和代理服务器都可以缓存max-age：缓存内容将在t秒后失效no-cache：需要使用协商缓存来验证数据no-store：所有内容都不会缓存 协商缓存协商缓存依赖于服务端与浏览器之间的通信。 协商缓存机制下，浏览器需要向服务器去询问缓存的相关信息，进而判断是重新发起请求、下载完整的响应，还是从本地获取缓存的资源。 如果服务端提示缓存资源未改动（Not Modified），资源会被重定向到浏览器缓存，这种情况下网络请求对应的状态码是 304（如下图）。 协商缓存的实: 从 Last-midified 到 EtagLast-Modified 是一个时间戳，如果我们启用了协商缓存，它会在首次请求时随着 Response Headers 返回： 1Last-Modified: Fri, 27 Oct 2020 06:35:57 GMT 随后我们每次请求时，会带上一个叫 If-Modified-Since 的时间戳字段，它的值正是上一次 response 返回给它的 last-modified 值： 1If-Modified-Since: Fri, 27 Oct 2020 06:35:57 GMT 服务器接收到这个时间戳后，会比对该时间戳和资源在服务器上的最后修改时间是否一致，从而判断资源是否发生了变化。如果发生了变化，就会返回一个完整的响应内容，并在 Response Headers 中添加新的 Last-Modified 值；否则，返回如上图的 304 响应，Response Headers 不会再添加 Last-Modified 字段。 使用 Last-Modified 存在一些弊端，这其中最常见的就是这样两个场景： 我们编辑了文件，但文件的内容没有改变。服务端并不清楚我们是否真正改变了文件，它仍然通过最后编辑时间进行判断。因此这个资源在再次被请求时，会被当做新资源，进而引发一次完整的响应——不该重新请求的时候，也会重新请求。 当我们修改文件的速度过快时（比如花了 100ms 完成了改动），由于 If-Modified-Since 只能检查到以秒为最小计量单位的时间差，所以它是感知不到这个改动的——该重新请求的时候，反而没有重新请求了。 这两个场景其实指向了同一个 bug ——服务器并没有正确感知文件的变化。为了解决这样的问题， Etag 作为 Last-Modified 的补充出现了。 Etag: 是由服务器为每个资源生成的唯一的标识字符串，这个标识字符串是基于文件内容编码的，只要文件内容不同，它们对应的 Etag 就是不同的，反之亦然。因此 Etag 能够精准地感知文件的变化。 Etag 和 Last-Modified 类似，当首次请求时，我们会在响应头里获取到一个最初的标识符字符串，举个🌰，它可以是这样的： 1ETag: W/&quot;wa3b-1231452&quot; 那么下一次请求时，请求头里就会带上一个值相同的、名为 if-None-Match 的字符串供服务端比对了： 1If-None-Match: W/&quot;wa3b-1231452&quot; 缓存的优点 减少了冗余的数据传递，节省宽带流量 减少了服务器的负担，大大提高了网站性能 加快了客户端加载网页的速度 不同刷新的请求执行过程 浏览器地址栏写入URL，回车，浏览器发现缓存中有这个文件了，不用继续请求了，直接去缓存拿。（最快） F5刷新，别偷懒好歹去服务器看看这个文件是否过期了。于是浏览器就在请求上带上一个if-modify-since。 Ctrl+F5告诉浏览器，你先把你缓存中的这个文件给我删了，然后再去服务器请求个完整的资源文件下来。于是客户端完成了强行更新的操作。]]></content>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css常见布局]]></title>
    <url>%2F2020%2F03%2F24%2F2020%2F3%E6%9C%88%2F0324-01%2F</url>
    <content type="text"><![CDATA[双飞燕布局圣杯布局1234567&lt;header&gt;圣杯布局&lt;/header&gt;&lt;div class="bd"&gt; &lt;div class="main"&gt;main&lt;/div&gt; &lt;div class="left"&gt;left&lt;/div&gt; &lt;div class="right"&gt;right&lt;/div&gt;&lt;/div&gt;&lt;footer&gt;footer&lt;/footer&gt; flex]]></content>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常见数据结构]]></title>
    <url>%2F2020%2F03%2F19%2F2020%2F3%E6%9C%88%2F0319-01%2F</url>
    <content type="text"><![CDATA[时间复杂度通常使用最差的时间复杂度来衡量一个算法的好坏。常数时间O(1)代表这个操作和数据量没有关系，是一个固定时间的操作，比如说四则运算。 对于一个算法来说，可能会计算出操作次数为 aN + 1，N代表数据量。那么该算法的时间复杂度就是O(N)。因为我们在计算时间复杂度的时候，数据量通常是非常大的，这时候低阶项和常数项可以忽略不计。 O(1) &lt; O(logn) &lt; O(n) &lt; O(nlogn) &lt; O(n^2) &lt; O(n^3) &lt; O(2^n) &lt; O(n!) &lt; O(n^n) 栈概念栈是一个线性结构，在计算机中是一个相当常见的数据结构。栈的特点是只能在某一端添加或删除数据，遵循先进后出的原则。 实现每种数据结构都可以用很多种方式来实现，其实可以把栈当做一个数组的子集，所以这里使用数组来实现 1234567891011121314151617181920class Stack &#123; constructor() &#123; this.stack = []; &#125; push(item) &#123; this.stack.push(item); &#125; pop() &#123; this.stack.pop(); &#125; getCount() &#123; return this.stack.length; &#125; peek() &#123; return this.stack[this.getCount - 1]; &#125; isEmpty() &#123; return this.getCount() === 0; &#125;&#125; 应用匹配括号，可以通过栈的特性来完成 12345678910111213141516171819202122232425262728var isValid = function(s) &#123; let map = &#123; '(': -1, ')': 1, '[': -2, ']': 2, '&#123;': -3, '&#125;': 3, &#125;; let stack = []; for (let i of s) &#123; if (map[i] &lt; 0) &#123; stack.push(i); &#125; else &#123; let last = stack.pop(); if (map[last] + map[i] !== 0) &#123; return false; &#125; &#125; &#125; if (stack.length &gt; 0) &#123; return false; &#125; return true;&#125; 队列概念队列是一个线性结构，特点是在某一端添加数据，在另一端删除数据，遵循先进先出的原则。 实现单链队列和循环队列 单链队列1234567891011121314151617181920class Queue &#123; constructor() &#123; this.queue = []; &#125; enQueue(item) &#123; this.queue.push(item); &#125; deQueue() &#123; return this.queue.shift(); &#125; getHeader() &#123; return this.queue[0]; &#125; getLength() &#123; return this.queue.length; &#125; isEmpty() &#123; return this.queue.length === 0; &#125;&#125; 循环队列链表]]></content>
      <tags>
        <tag>计算机知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[总结]]></title>
    <url>%2F2020%2F03%2F17%2F2020%2F3%E6%9C%88%2F0317-01%2F</url>
    <content type="text"><![CDATA[如何实现一个babel插件Babel 是 JavaScript 编译器，更确切地说是源码到源码的编译器，通常也叫做“转换编译器（transpiler）”。 意思是说你为 Babel 提供一些 JavaScript 代码，Babel 更改这些代码，然后返回给你新生成的代码。 抽象语法树（AST）Babel 的处理步骤Babel 的三个主要处理步骤分别是： 解析（parse），转换（transform），生成（generate）。 如何实现一个webpack-loader 如何实现一个webpack-plugins 如何实现一个promise12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970const PENDING = 'PENDING';const RESOLVED = 'RESOLVED';const REJECTED = 'REJECTED';function MyPromise(fn) &#123; const that = this; that.value = null; that.state = PENDING; that.resolvedCallbacks = []; that.rejectedCallbacks = []; function resolve(value) &#123; if (value instanceof MyPromise) &#123; return value.then(resolve, reject); &#125; if (that.state === PENDING) &#123; that.state = RESOLVED; that.value = value; that.resolvedCallbacks.map(cb =&gt; cb(that.value)); &#125; &#125; function reject(value) &#123; if (that.state === PENDING) &#123; that.state = REJECTED; that.value = value; that.rejectedCallbacks.map(cb =&gt; cb(that.value)); &#125; &#125; try &#123; fn(resolve, reject); &#125; catch(e) &#123; reject(e); &#125;&#125;MyPromise.prototype.then = function(onFulfilled, onRejected) &#123; const that = this; onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : v =&gt; v; onRejected = typeof onRejected === 'function' ? onRejected : r =&gt; &#123; throw r &#125;; if (that.state === PENDING) &#123; that.resolvedCallbacks.push(onFulfilled); that.rejectedCallbacks.push(onRejected); &#125; if (that.state === RESOLVED) &#123; onFulfilled(that.value); &#125; if (that.state === REJECTED) &#123; onRejected(that.value); &#125; return that;&#125;new MyPromise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(111); &#125;, 0);&#125;).then(value =&gt; &#123; console.log(value);&#125;).then(value =&gt; &#123; console.log(value);&#125;) node调试，错误监控 http和https区别https就是http和TCP之间有一层SSL层，这一层的实际作用是防止钓鱼和加密。防止钓鱼通过网站的证书，网站必须有CA证书，证书类似于一个解密的签名。另外是加密，加密需要一个密钥交换算法，双方通过交换后的密钥加解密。 https协议需要到ca申请证书，一般免费证书很少，需要交费。 http是超文本传输协议，信息是明文传输，https 则是具有安全性的ssl加密传输协议。 http和https使用的是完全不同的连接方式用的端口也不一样，前者是80，后者是443。 http的连接很简单，是无状态的。 HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全。 百度和谷歌两大搜索引擎都已经明确表示，HTTPS网站将会作为搜索排名的一个重要权重指标。也就是说HTTPS网站比起HTTP网站在搜索排名中更有优势。 react，vue生命周期vue brforeCreate create beforeMountd mounted beforeUpdate updated activated deactivated beforeDestroy destroy errorCaptured reactcalss编程生命周期 初始阶段 constructor 挂载阶段 componentWillMount render componentDidMount 更新阶段 componentWillReceiveProps shouldComponentUpdate componentWillUpdate render componentDidUpdate 卸载阶段 componentWillUnmount 到了React v16.3，大改动来了，引入了两个新的生命周期函数： getDerivedStateFromProps，getSnapshotBeforeUpdate static getDerivedStateFromProps(props, state) 在组件创建时和更新时的render方法之前调用，它应该返回一个对象来更新状态，或者返回null来不更新任何内容。 getSnapshotBeforeUpdate() 被调用于render之后，可以读取但无法使用DOM的时候。它使您的组件可以在可能更改之前从DOM捕获一些信息（例如滚动位置）。此生命周期返回的任何值都将作为参数传递给componentDidUpdate（）。 1234567891011121314151617181920212223242526272829303132class ScrollingList extends React.Component &#123; constructor(props) &#123; super(props); this.listRef = React.createRef(); &#125; getSnapshotBeforeUpdate(prevProps, prevState) &#123; //我们是否要添加新的 items 到列表? // 捕捉滚动位置，以便我们可以稍后调整滚动. if (prevProps.list.length &lt; this.props.list.length) &#123; const list = this.listRef.current; return list.scrollHeight - list.scrollTop; &#125; return null; &#125; componentDidUpdate(prevProps, prevState, snapshot) &#123; //如果我们有snapshot值, 我们已经添加了 新的items. // 调整滚动以至于这些新的items 不会将旧items推出视图。 // (这边的snapshot是 getSnapshotBeforeUpdate方法的返回值) if (snapshot !== null) &#123; const list = this.listRef.current; list.scrollTop = list.scrollHeight - snapshot; &#125; &#125; render() &#123; return ( &lt;div ref=&#123;this.listRef&#125;&gt;&#123;/* ...contents... */&#125;&lt;/div&gt; ); &#125;&#125; redux和rematch webpack性能优化减少webpack打包时间 优化 Loader 对于 Loader 来说，影响打包效率首当其冲必属 Babel 了。因为 Babel 会将代码转为字符串生成 AST，然后对 AST 继续进行转变最后再生成新的代码，项目越大，转换代码越多，效率就越低。当然了，我们是有办法优化的。 首先我们可以优化 Loader 的文件搜索范围 123456789101112131415module.exports = &#123; module: &#123; rules: [ &#123; // js 文件才使用 babel test: /\.js$/, loader: 'babel-loader', // 只在 src 文件夹下查找 include: [resolve('src')], // 不会去查找的路径 exclude: /node_modules/ &#125; ] &#125;&#125; 对于 Babel 来说，我们肯定是希望只作用在 JS 代码上的，然后 node_modules 中使用的代码都是编译过的，所以我们也完全没有必要再去处理一遍。 当然这样做还不够，我们还可以将 Babel 编译过的文件缓存起来，下次只需要编译更改过的代码文件即可，这样可以大幅度加快打包时间 1loader: 'babel-loader?cacheDirectory=true' HappyPack 受限于 Node 是单线程运行的，所以 Webpack 在打包的过程中也是单线程的，特别是在执行 Loader 的时候，长时间编译的任务很多，这样就会导致等待的情况。HappyPack 可以将 Loader 的同步执行转换为并行的，这样就能充分利用系统资源来加快打包效率 12345678910111213141516171819module: &#123; loaders: [ &#123; test: /\.js$/, include: [resolve('src')], exclude: /node_modules/, // id 后面的内容对应下面 loader: 'happypack/loader?id=happybabel' &#125; ]&#125;,plugins: [ new HappyPack(&#123; id: 'happybabel', loaders: ['babel-loader?cacheDirectory'], // 开启 4 个线程 threads: 4 &#125;)] DllPlugin DllPlugin 可以将特定的类库提前打包然后引入。这种方式可以极大的减少打包类库的次数，只有当类库更新版本才有需要重新打包，并且也实现了将公共代码抽离成单独文件的优化方案。 减少webpack打包后的体积 按需加载 想必大家在开发 SPA 项目的时候，项目中都会存在十几甚至更多的路由页面。如果我们将这些页面全部打包进一个 JS 文件的话，虽然将多个请求合并了，但是同样也加载了很多并不需要的代码，耗费了更长的时间。那么为了首页能更快地呈现给用户，我们肯定是希望首页能加载的文件体积越小越好，这时候我们就可以使用按需加载，将每个路由页面单独打包为一个文件。当然不仅仅路由可以按需加载，对于 loadash 这种大型类库同样可以使用这个功能。 监控前端监控一般分为三种，分别为页面埋点、性能监控以及异常监控。 页面埋点页面埋点应该是大家最常写的监控了，一般起码会监控以下几个数据： PV/UV 停留时长 流量来源 用户交互 对于这几类统计，一般的实现思路大致可以分为两种，分别为手写埋点和无埋点的方式。 相信第一种方式也是大家最常用的方式，可以自主选择需要监控的数据然后在相应的地方写入代码。这种方式的灵活性很大，但是唯一的缺点就是工作量较大，每个需要监控的地方都得插入代码。 另一种无埋点的方式基本不需要开发者手写埋点了，而是统计所有的事件并且定时上报。这种方式虽然没有前一种方式繁琐了，但是因为统计的是所有事件，所以还需要后期过滤出需要的数据。 性能监控性能监控可以很好的帮助开发者了解在各种真实环境下，页面的性能情况是如何的。 对于性能监控来说，我们可以直接使用浏览器自带的 Performance API 来实现这个功能。 对于性能监控来说，其实我们只需要调用 performance.getEntriesByType(‘navigation’) 这行代码就行了。对，你没看错，一行代码我们就可以获得页面中各种详细的性能相关信息。 异常监控对于异常监控来说，以下两种监控是必不可少的，分别是代码报错以及接口异常上报 对于代码运行错误，通常的办法是使用window.onerror拦截报错。该方法能拦截到大部分的详细报错信息，但是也有例外。 12345678910111213/** * @param &#123;String&#125; msg 错误信息 * @param &#123;String&#125; url 出错文件 * @param &#123;Number&#125; row 行号 * @param &#123;Number&#125; col 列号 * @param &#123;Object&#125; error 错误详细信息 */window.onerror = function (msg, url, row, col, error) &#123; console.log(&#123; msg, url, row, col, error &#125;) return true; // 注意，在返回 true 的时候，异常才不会继续向上抛出error;&#125;; 对于跨域的代码运行错误会显示Script error。对于这种情况我们需要给script标签添加crossorigin属性 对于某些浏览器可能不会显示调用栈信息，这种情况通过arguments.callee.caller来做栈递归。 对于异步代码来说，可以使用catch的方式捕获错误。比如Promise可以直接使用catch函数，await async可以使用try catch。 但是要注意线上运行的代码都是压缩过的，需要在打包时生成sourceMap文件便于debug。 对于捕获的错误需要上传给服务器**可以通过ajax发送数据还可以通过img标签的src发起一个请求。 1234function report(error) &#123; var report = 'https://xxx/report'; new Image().src = report + 'error=' + error;&#125; 另外接口异常就相对来说简单了，可以列举出出错的状态码。一旦出现此类的状态码就可以立即上报出错。接口异常上报可以让开发人员迅速知道有哪些接口出现了大面积的报错，以便迅速修复问题。 普通函数跟箭头函数的区别 语法更加简洁、清晰 箭头函数不会创建自己的this，它只会从自己的作用域链的上一层继承this 12345678910111213var id = 'GLOBAL';var obj = &#123; id: 'OBJ', a: function()&#123; console.log(this.id); &#125;, b: () =&gt; &#123; console.log(this.id); &#125;&#125;;obj.a(); // 'OBJ'obj.b(); // 'GLOBAL' 箭头函数继承而来的this指向永远不变 call/apply/bind无法改变箭头函数中this的指向 .call()/.apply()/.bind()方法可以用来动态修改函数执行时this的指向，但由于箭头函数的this定义时就已经确定且永远不会改变。所以使用这些方法永远也改变不了箭头函数this的指向，虽然这么做代码不会报错。 1234567891011var id = 'Global';// 箭头函数定义在全局作用域let fun1 = () =&gt; &#123; console.log(this.id)&#125;;fun1(); // 'Global'// this的指向不会改变，永远指向Window对象fun1.call(&#123;id: 'Obj'&#125;); // 'Global'fun1.apply(&#123;id: 'Obj'&#125;); // 'Global'fun1.bind(&#123;id: 'Obj'&#125;)(); // 'Global' 箭头函数不能作为构造函数使用 因为箭头函数没有自己的this，它的this其实是继承了外层执行环境中的this，且this指向永远不会随在哪里调用、被谁调用而改变，所以箭头函数不能作为构造函数使用，或者说构造函数不能定义成箭头函数，否则用new调用时会报错！ 1234567let Fun = (name, age) =&gt; &#123; this.name = name; this.age = age;&#125;;// 报错let p = new Fun('cao', 24); 箭头函数没有自己的arguments，在箭头函数中访问arguments实际上获得的是外层局部（函数）执行环境中的值。 12345678910111213141516171819202122// 例子一let fun = (val) =&gt; &#123; console.log(val); // 111 // 下面一行会报错 // Uncaught ReferenceError: arguments is not defined // 因为外层全局环境没有arguments对象 console.log(arguments);&#125;;fun(111);// 例子二function outer(val1, val2) &#123; let argOut = arguments; console.log(argOut); // [111, 222] let fun = () =&gt; &#123; let argIn = arguments; console.log(argIn); // // [111, 222] console.log(argOut === argIn); // true &#125;; fun();&#125;outer(111, 222); 箭头函数没有原型prototype 1234let sayHi = () =&gt; &#123; console.log('Hello World !')&#125;;console.log(sayHi.prototype); // undefined 手写一个webpack 手写一个webpack]]></content>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js实现深拷贝]]></title>
    <url>%2F2020%2F03%2F15%2F2020%2F3%E6%9C%88%2F0315-02%2F</url>
    <content type="text"><![CDATA[深浅拷贝浅拷贝 Object.assign 展开运算符… Array.slice(); 首先可以通过 Object.assign 来解决这个问题，很多人认为这个函数是用来深拷贝的。其实并不是，Object.assign 只会拷贝所有的属性值到新的对象中，如果属性值是对象的话，拷贝的是地址，所以并不是深拷贝。 123456let a = &#123; age: 1&#125;let b = Object.assign(&#123;&#125;, a)a.age = 2console.log(b.age) // 1 另外我们还可以通过展开运算符 … 来实现浅拷贝 123456let a = &#123; age: 1&#125;let b = &#123; ...a &#125;a.age = 2console.log(b.age) // 1 通常浅拷贝就能解决大部分问题了，但是当我们遇到如下情况就可能需要使用到深拷贝了 123456789let a = &#123; age: 1, jobs: &#123; first: 'FE' &#125;&#125;let b = &#123; ...a &#125;a.jobs.first = 'native'console.log(b.jobs.first) // native 浅拷贝只解决了第一层的问题，如果接下去的值中还有对象的话，那么就又回到最开始的话题了，两者享有相同的地址。要解决这个问题，我们就得使用深拷贝了。 深拷贝这个问题通常可以通过 JSON.parse(JSON.stringify(object)) 来解决。 123456789let a = &#123; age: 1, jobs: &#123; first: 'FE' &#125;&#125;let b = JSON.parse(JSON.stringify(a))a.jobs.first = 'native'console.log(b.jobs.first) // FE 但是该方法也是有局限性的： 会忽略 undefined 会忽略 symbol 不能序列化函数 不能解决循环引用的对象 1234567891011121314let obj = &#123; a: 1, b: &#123; c: 2, d: 3, &#125;,&#125;obj.c = obj.bobj.e = obj.aobj.b.c = obj.cobj.b.d = obj.bobj.b.e = obj.b.clet newObj = JSON.parse(JSON.stringify(obj))console.log(newObj) 如果你有这么一个循环引用对象，你会发现并不能通过该方法实现深拷贝在遇到函数、 undefined 或者 symbol 的时候，该对象也不能正常的序列化 12345678let a = &#123; age: undefined, sex: Symbol('male'), jobs: function() &#123;&#125;, name: 'yck'&#125;let b = JSON.parse(JSON.stringify(a))console.log(b) // &#123;name: "yck"&#125; 你会发现在上述情况中，该方法会忽略掉函数和 undefined 。 但是在通常情况下，复杂数据都是可以序列化的，所以这个函数可以解决大部分问题。 如果你所需拷贝的对象含有内置类型并且不包含函数，可以使用 MessageChannel 当然你可能想自己来实现一个深拷贝，但是其实实现一个深拷贝是很困难的，需要我们考虑好多种边界情况，比如原型链如何处理、DOM 如何处理等等，所以这里我们实现的深拷贝只是简易版，并且我其实更推荐使用 lodash 的深拷贝函数。 123456789101112131415161718function deepClone(obj) &#123; function isObject(o) &#123; return (typeof o === 'object' || typeof o === 'function') &amp;&amp; o !== null; &#125; if (!isObject(obj)) &#123; throw new Error('非对象'); &#125; let isArray = Array.isArray(obj); let newObj = isArray ? [...obj] : &#123;...obj&#125;; Reflect.hasOwn(newObj).forEach(key =&gt; &#123; newObj[key] = isObject(obj[key]) ? deepClone(newObj[key]) : obj[key]; &#125;) return newObj;&#125;]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端安全问题]]></title>
    <url>%2F2020%2F03%2F15%2F2020%2F3%E6%9C%88%2F0315-01%2F</url>
    <content type="text"><![CDATA[XSSXSS 简单点来说，就是攻击者想尽一切办法将可以执行的代码注入到网页中。XSS 可以分为多种类型，但是总体上我认为分为两类：持久型和非持久型。 持久型也就是攻击的代码被服务端写入进数据库中，这种攻击危害性很大，因为如果网站访问量很大的话，就会导致大量正常访问页面的用户都受到攻击。 举个例子，对于评论功能来说，就得防范持久型 XSS 攻击，因为我可以在评论中输入以下内容 1&lt;script&gt;alert(1);&lt;/script&gt; 非持久型相比于前者危害就小的多了，一般通过修改 URL 参数的方式加入攻击代码，诱导用户访问链接从而进行攻击。 举个例子，如果页面需要从 URL 中获取某些参数作为内容的话，不经过过滤就会导致攻击代码被执行 12&lt;!-- http://www.domain.com?name=&lt;script&gt;alert(1)&lt;/script&gt; --&gt;&lt;div&gt;&#123;&#123;name&#125;&#125;&lt;/div&gt; 但是对于这种攻击方式来说，如果用户使用 Chrome 这类浏览器的话，浏览器就能自动帮助用户防御攻击。但是我们不能因此就不防御此类攻击了，因为我不能确保用户都使用了该类浏览器。 对于 XSS 攻击来说，通常有两种方式可以用来防御。 转义字符首先，对于用户的输入应该是永远不信任的。最普遍的做法就是转义输入输出的内容，对于引号、尖括号、斜杠进行转义 12345678910function escape(str) &#123; str = str.replace(/&amp;/g, '&amp;amp;') str = str.replace(/&lt;/g, '&amp;lt;') str = str.replace(/&gt;/g, '&amp;gt;') str = str.replace(/"/g, '&amp;quto;') str = str.replace(/'/g, '&amp;#39;') str = str.replace(/`/g, '&amp;#96;') str = str.replace(/\//g, '&amp;#x2F;') return str&#125; CSPCSP 本质上就是建立白名单，开发者明确告诉浏览器哪些外部资源可以加载和执行。我们只需要配置规则，如何拦截是由浏览器自己实现的。我们可以通过这种方式来尽量减少 XSS 攻击。 通常可以通过两种方式来开启 CSP： 设置 HTTP Header 中的 Content-Security-Policy 设置 meta 标签的方式 CSRFCSRF 中文名为跨站请求伪造。原理就是攻击者构造出一个后端请求地址，诱导用户点击或者通过某些途径自动发起请求。如果用户是在登录状态下的话，后端就以为是用户在操作，从而进行相应的逻辑。 举个例子，假设网站中有一个通过 GET 请求提交用户评论的接口，那么攻击者就可以在钓鱼网站中加入一个图片，图片的地址就是评论接口 1&lt;img src="http://www.domain.com/xxx?comment='attack'"/&gt; 那么你是否会想到使用 POST 方式提交请求是不是就没有这个问题了呢？其实并不是，使用这种方式也不是百分百安全的，攻击者同样可以诱导用户进入某个页面，在页面中通过表单提交 POST 请求。 如何防御防范 CSRF 攻击可以遵循以下几种规则： Get 请求不对数据进行修改 不让第三方网站访问到用户 Cookie 阻止第三方网站请求接口 请求时附带验证信息，比如验证码或者 Token SameSite可以对 Cookie 设置 SameSite 属性。该属性表示 Cookie 不随着跨域请求发送，可以很大程度减少 CSRF 的攻击，但是该属性目前并不是所有浏览器都兼容。 验证 Referer对于需要防范 CSRF 的请求，我们可以通过验证 Referer 来判断该请求是否为第三方网站发起的。 Token服务器下发一个随机 Token，每次发起请求时将 Token 携带上，服务器验证 Token 是否有效。 点击劫持点击劫持是一种视觉欺骗的攻击手段。攻击者将需要攻击的网站通过 iframe 嵌套的方式嵌入自己的网页中，并将 iframe 设置为透明，在页面中透出一个按钮诱导用户点击。 对于这种攻击方式，推荐防御的方法有两种。 X-FRAME-OPTIONSX-FRAME-OPTIONS 是一个 HTTP 响应头，在现代浏览器有一个很好的支持。这个 HTTP 响应头 就是为了防御用 iframe 嵌套的点击劫持攻击。 该响应头有三个值可选，分别是 DENY，表示页面不允许通过 iframe 的方式展示 SAMEORIGIN，表示页面可以在相同域名下通过 iframe 的方式展示 ALLOW-FROM，表示页面可以在指定来源的 iframe 中展示 JS 防御对于某些远古浏览器来说，并不能支持上面的这种方式，那我们只有通过 JS 的方式来防御点击劫持了。 1234567891011121314151617&lt;head&gt; &lt;style id="click-jack"&gt; html &#123; display: none !important; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; if (self == top) &#123; var style = document.getElementById('click-jack') document.body.removeChild(style) &#125; else &#123; top.location = self.location &#125; &lt;/script&gt;&lt;/body&gt; 以上代码的作用就是当通过 iframe 的方式加载页面时，攻击者的网页直接不显示所有内容了。 中间人攻击中间人攻击是攻击方同时与服务端和客户端建立起了连接，并让对方认为连接是安全的，但是实际上整个通信过程都被攻击者控制了。攻击者不仅能获得双方的通信信息，还能修改通信信息。 通常来说不建议使用公共的 Wi-Fi，因为很可能就会发生中间人攻击的情况。如果你在通信的过程中涉及到了某些敏感信息，就完全暴露给攻击方了。 当然防御中间人攻击其实并不难，只需要增加一个安全通道来传输信息。HTTPS 就可以用来防御中间人攻击，但是并不是说使用了 HTTPS 就可以高枕无忧了，因为如果你没有完全关闭 HTTP 访问的话，攻击方可以通过某些方式将 HTTPS 降级为 HTTP 从而实现中间人攻击。]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS数据类型]]></title>
    <url>%2F2020%2F03%2F13%2F2020%2F3%E6%9C%88%2F0313-01%2F</url>
    <content type="text"><![CDATA[原始(Primitive)类型在JS中，存在6种原始值，分别是： number string boolean null undefined symbol bigInt 首先原始类型存储的都是值，是没有函数可以调用的，比如undefined.toString() 此时你肯定会有疑问，这不对啊，明明’1’.toString()是可以使用的。其实在这种情况下，’1’已经不是原始类型了，而是被强制转换成了String类型也就是对象类型，所以可以调用tostring函数。 另外对于null来说，很多人会认为它是个对象类型，其实这是错的。虽然typeof null会输出object，但是这是JS存在的一个历史bug。在 JS 的最初版本中使用的是 32 位系统，为了性能考虑使用低位存储变量的类型信息，000 开头代表是对象，然而 null 表示为全零，所以将它错误的判断为 object。虽然现在的内部类型判断代码已经改变了，但是对于这个 Bug 却是一直流传下来。 对象类型在JS中，除了原始类型就是对象类型了。对象类型和原始类型的不同的是，原始类型存储的是值，对象类型存储的地址（指针）。当你创建了一个对象类型的时候，计算机会在内存中帮我们开辟一个空间来存放值，但是我们需要找到这个空间，这个空间会拥有一个地址（指针）。 类型转换首先我们要知道，在 JS 中类型转换只有三种情况，分别是： 转换为布尔值 转换为数字 转换为字符串 转Boolean在条件判断时，除了 undefined， null， false， NaN， ‘’， 0， -0，其他所有值都转为 true，包括所有对象。 对象转原始类型对象在转换类型的时候，会调用内置的 [[ToPrimitive]] 函数，对于该函数来说，算法逻辑一般来说如下： 如果是原始类型，那就不需要转换 如果需要转字符串类型那就调用x.toString()，转换为基础类型的话就会返回转换的值。不是字符串类型的话就先调用valueOf，如果不是基础类型的话在调用toString。 调用x.valueOf()，如果转换为基础类型，就返回基础类型。 如果都没有返回原始类型，就会报错。 当然你也可以重写 Symbol.toPrimitive，该方法在转原始类型时调用优先级最高。 123456789101112let a = &#123; valueOf() &#123; return 0; &#125;, toString() &#123; return '1'; &#125; [Symbol.toPrimitive]() &#123; return 2; &#125;&#125;console.log(1 + a); // 3 如何实现 a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3返回true 1234567var a = &#123; value: 1, toString() &#123; return a.value++ &#125;&#125;a == 1 &amp;&amp; a == 2 &amp;&amp; a == 3 比较运算符 如果是对象，就通过 toPrimitive 转成原始类型 如果是字符串，就通过 unicode 字符索引来比较 123456789let a = &#123; valueOf() &#123; return 0; &#125;, toString() &#123; return '1' &#125;&#125;a &gt; -1; // true]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP]]></title>
    <url>%2F2020%2F03%2F11%2F2020%2F3%E6%9C%88%2F0311-02%2F</url>
    <content type="text"><![CDATA[TCP传输控制协议（TCP，Transmission Control Protocol）是一种面向连接的、可靠的、基于字节流的传输层通信协议。TCP 基本是和 UDP 反着来，建立连接断开连接都需要先需要进行握手。在传输数据的过程中，通过各种算法保证数据的可靠性，当然带来的问题就是相比 UDP 来说不那么的高效。 三次握手首先假设主动发起请求的一端称为客户端，被动连接的一端称为服务端。不管是客户端还是服务端，TCP 连接建立完后都能发送和接收数据，所以 TCP 是一个全双工的协议。起初，两端都为 CLOSED 状态。在通信开始前，双方都会创建 TCB。 服务器创建完 TCB 后便进入 LISTEN 状态，此时开始等待客户端发送数据。 第一次握手 客户端向服务端发送连接请求报文段。该报文段中包含自身的数据通讯初始序号。请求发送后，客户端便进入 SYN-SENT 状态。 第二次握手 服务端收到连接请求报文段后，如果同意连接，则会发送一个应答，该应答中也会包含自身的数据通讯初始序号，发送完成后便进入 SYN-RECEIVED 状态。 第三次握手 当客户端收到连接同意的应答后，还要向服务端发送一个确认报文。客户端发完这个报文段后便进入 ESTABLISHED 状态，服务端收到这个应答后也进入 ESTABLISHED 状态，此时连接建立成功。 四次挥手TCP 是全双工的，在断开连接时两端都需要发送 FIN 和 ACK。 第一次： 当主机A完成数据传输后,将控制位FIN置1，提出停止TCP连接的请求 ； 第二次： 主机B收到FIN后对其作出响应，确认这一方向上的TCP连接将关闭,将ACK置1； 第三次： 由B 端再提出反方向的关闭请求,将FIN置1 ； 第四次： 主机A对主机B的请求进行确认，将ACK置1，双方向的关闭结束。 名词解释1、ACK 是TCP报头的控制位之一，对数据进行确认。确认由目的端发出， 用它来告诉发送端这个序列号之前的数据段都收到了。 比如确认号为X，则表示前X-1个数据段都收到了，只有当ACK=1时,确认号才有效，当ACK=0时，确认号无效，这时会要求重传数据，保证数据的完整性。 2、SYN 同步序列号，TCP建立连接时将这个位置1。 3、FIN 发送端完成发送任务位，当TCP完成数据传输需要断开时， 提出断开连接的一方将这位置1。 小结TCP与UDP的区别：1.（基于连接vs无连接）tcp是面向连接的（三次握手；四次挥手）；udp不是面向连接的2.（重量级vs轻量级）tcp是一个重量级的协议；udp则是轻量级的协议。一个tcp数据报的报头大小最少20字节，udp数据报的包头固定8个字节3.（可靠性）tcp交付保证：如果消息在传输中丢失，那么它将重发；udp没有交付保证，一个数据包在运输过程中可能丢失。4.（有序性）消息到达网络的另一端可能是无序的，tcp协议将为你拍好序。Udp不提供任何有序性的保证。5.（速度）tcp慢，适合传输大量数据；udp快，适合传输少量数据。6.（流量控制和拥塞控制）TCP有流量控制和拥塞控制，udp没有。 tcp面向字节流，udp面向报文 tcp只能单播，不能发送广播和组播；udp可以广播和组播。 流量控制和拥塞控制： 流量控制：就是让发送方发送速率不要太快，要让接收方来的及接收。 拥塞控制：防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提：网络能够承受现有的网络负荷。拥塞控制是一个全局性的过程，涉及到所有的主机、路由器，以及与降低网络传输性能有关的所有因素。]]></content>
      <tags>
        <tag>网络协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UDP]]></title>
    <url>%2F2020%2F03%2F11%2F2020%2F3%E6%9C%88%2F0311-01%2F</url>
    <content type="text"><![CDATA[UDPUDP协议是面向无连接的，也就是说不需要在正式传递数据之前先连接起双方。然后UDP协议只是数据报文的搬运工，不保证有序且不丢失的传递到对端，并且UDP协议也没有任何控制流量的算法，总的来说UDP相较于TCP更加的轻便。 我们经常使用“ping”命令来测试两台主机之间TCP/IP通信是否正常， 其实“ping”命令的原理就是向对方主机发送UDP数据包，然后对方主机确认收到数据包， 如果数据包是否到达的消息及时反馈回来，那么网络就是通的。 面向无连接UDP是不需要和TCP一样在发送数据前进行3次握手建立连接的，想发数据就可以发送了。并且也只是数据报文的搬运工，不会对数据报文进行任何拆分和拼接操作。 具体来说： 在发送端，应用层将数据传递给传输层的UDP协议，UDP只会给数据增加一个UDP头标识下是UDP协议，然后就传递给网络层 在接收端，网络层将数据传递给传输层，UDP只去除IP报文头就传递给应用层，不会任何拼接操作 不可靠性首先不可靠性体现在无连接上，通信都不需要建立连接，想发就发，这样的情况肯定不可靠。并且收到什么数据就传递什么数据，并且也不会备份数据，发送数据也不会关心对方是否已经正确接收到数据了。再者网络环境时好时坏，但是 UDP 因为没有拥塞控制，一直会以恒定的速度发送数据。即使网络条件不好，也不会对发送速率进行调整。这样实现的弊端就是在网络条件不好的情况下可能会导致丢包，但是优点也很明显，在某些实时性要求高的场景（比如电话会议）就需要使用 UDP 而不是 TCP。 高效虽然 UDP 协议不是那么的可靠，但是正是因为它不是那么的可靠，所以也就没有 TCP 那么复杂了，需要保证数据不丢失且有序到达。因此 UDP 的头部开销小，只有八字节，相比 TCP 的至少二十字节要少得多，在传输数据报文时是很高效的。 传输方式UDP 不止支持一对一的传输方式，同样支持一对多，多对多，多对一的方式，也就是说 UDP 提供了单播，多播，广播的功能。 适合使用的场景 直播 想必大家都看过直播吧，大家可以考虑下如果直播使用了基于 TCP 的协议会发生什么事情？ TCP 会严格控制传输的正确性，一旦有某一个数据对端没有收到，就会停止下来直到对端收到这个数据。这种问题在网络条件不错的情况下可能并不会发生什么事情，但是在网络情况差的时候就会变成画面卡住，然后再继续播放下一帧的情况。 但是对于直播来说，用户肯定关注的是最新的画面，而不是因为网络条件差而丢失的老旧画面，所以 TCP 在这种情况下无用武之地，只会降低用户体验。 王者荣耀 为什么这样说呢？首先对于王者荣耀来说，用户体量是相当大的，如果使用 TCP 连接的话，就可能会出现服务器不够用的情况，因为每台服务器可供支撑的 TCP 连接数量是有限制的。 再者，因为 TCP 会严格控制传输的正确性，如果因为用户网络条件不好就造成页面卡顿然后再传输旧的游戏画面是肯定不能接受的，毕竟对于这类实时性要求很高的游戏来说，最新的游戏画面才是最需要的，而不是老旧的画面，否则角色都不知道死多少次了。 总结 UDP 相比 TCP 简单的多，不需要建立连接，不需要验证数据报文，不需要流量控制，只会把想发的数据报文一股脑的丢给对端 虽然 UDP 并没有 TCP 传输来的准确，但是也能在很多实时性要求高的地方有所作为]]></content>
      <tags>
        <tag>网络协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面经]]></title>
    <url>%2F2020%2F03%2F10%2F2020%2F3%E6%9C%88%2F0310-01%2F</url>
    <content type="text"><![CDATA[说说你对JS模块化的理解模块化就是将一个大的功能拆分为多个块，每一个块都是独立的，你不需要去担心污染全局变量，命名冲突什么的。 那么模块化的好处也就显然易见了 解决命名冲突 依赖管理 代码更加可读 提高复用性 js设计之初并没有模块化的概念，所以原始时代只能通过自执行函数来设计模块化 123456789101112131415var myModule = (function(window) &#123; // private var moduleName = 'module'; // public function setModuleName(name) &#123; moduleName = name; &#125;; // public function getModuleName() &#123; return moduleName; &#125;; return &#123;setModuleName, getModuleName&#125;;&#125;)(window); 它通过闭包的特性打开了一个新的作用域，缓解了全局作用域命名冲突和安全性的问题。但是，开发者并不能够用它来组织和拆分代码，于是乎便出现了以此为基石的模块化规范。 1. CommonJs规范（同步加载模块） 允许模块通过require的方法来同步加载所要依赖的其他模块，然后通过exports或module.exports来导出需要暴露的接口 123456789101112// a.jsmodule.exports = &#123; a: 1,&#125;;// orexports.a = 1;// b.jsvar module = require('./a.js');module.a = 1;// require函数同步加载了a.js，并且返回了module.exports输出字面量的拷贝值。 优点： 简单容易使用 服务器端模块便于复用 缺点： 同步加载的方式不适合在浏览器环境中使用，同步意味着阻塞加载，浏览器资源是异步加载 不能非阻塞的并行加载多个模块 2. AMD（异步加载模块）区别于CommonJS，AMD规范的被依赖模块是异步加载的，而定义的模块是被当作回调函数来执行的，依赖于require.js模块管理工具库。 1234define(['./a', './b'], function(a, b) &#123; a.do(); b.do();&#125;) 3. CMD（异步加载模块）CMD 是 SeaJS 在推广过程中对模块定义的规范化产出。AMD 推崇依赖前置，CMD 推崇依赖就近。 123456789101112define(function(require, exports, module) &#123; var a = require('./a'); a.doSomething(); // 异步加载一个模块，在加载完成时，执行回调 require.async(['./b'], function(b) &#123; b.doSomething(); &#125;); // 对外暴露成员 exports.doSomething = function() &#123;&#125;;&#125;)// 使用模块seajs.use('path'); 4. ES6 moduleES6的模块化已经不是规范了，而是JS语言的特性。 12345// 引入的语法就这样 import，XXX 这里有很多语法变化import XXX from './a.js'// 导出也有很多语法变化的写法，基本的就这两个，反正语法没什么难得export function a() &#123;&#125;export default function() &#123;&#125; 随着ES6的推出，AMD和CMD也随之成为了历史。ES6模块与模块化规范相比，有两大特点： 模块化规范输出的是一个值的拷贝，ES6 模块输出的是值的引用。 模块化规范是运行时加载，ES6 模块是编译时输出接口。 commonJs 123456789101112131415var count = 1;function add() &#123; count++;&#125;module.exports = &#123; count, add,&#125;var v = require('./common');console.log(v.count); // 1v.add();console.log(v.count); // 1 ES6 123456789101112131415var count = 1;function add() &#123; count++;&#125;export default &#123; count, add&#125;import v from './common';console.log(v.count); // 1v.add();console.log(v.count); // 2 如何理解原型？如何理解原型链？ prototype这是一个显式原型属性，任何一个对象都有原型，但是有一个例外 1let fun = Function.prototype.bind(); 如果你已上述方法创建一个函数，那么可以发现这个函数不具有prototype属性。 prototype 如何产生的当我们声明一个函数时，这个属性就被自动创建了 1function Foo() &#123;&#125; 并且这个属性的值是一个对象（也就是原型），只有一个属性constructor constructorconstructor 是一个公有且不可枚举的属性。一旦我们改变了函数的prototype，那么新对象就没有这个属性了（当然可以通过原型链取到constructor） __proto__这是每个对象都有的隐式原型属性，指向了创建该对象的构造函数的原型。其实这个属性指向了 [[prototype]]，但是 [[prototype]] 是内部属性，我们并不能访问到，所以使用 __proto__ 来访问。 **实例对象的 __proto__ 如何产生的 当我们使用 new 操作符时，生成的实例对象拥有了 proto属性。 1function Foo() &#123;&#125; // 这个函数是 Function的实例对象 1234567891011// 纯对象的原型console.log(&#123;&#125;.__proto__); // &#123;&#125;function Student(name) &#123; this.name = name;&#125;const stu = new Student('wang');// Student 类型实例的原型，默认也是一个对象console.log(stu.__proto__); // &#123; constructor: f &#125;console.log(stu.__proto__.constructor); // Student(name, age) &#123; this.name = name &#125; new做了什么，new的模拟实现 创建了一个全新的对象。 这个对象会被执行[[Prototype]]（也就是proto）链接。 生成的新对象会绑定到函数调用的this。 通过new创建的每个对象将最终被[[Prototype]]链接到这个函数的prototype对象上。 如果函数没有返回对象类型Object(包含Functoin, Array, Date, RegExg, Error)，那么new表达式中的函数调用会自动返回这个新的对象。 1234567891011121314151617/** * 模拟实现 new 操作符 * @param &#123;Function&#125; ctor [构造函数] * @return &#123;Object|Function|Regex|Date|Error&#125; [返回结果] */function create() &#123; // 创建一个空的对象 let obj = new Object() // 获得构造函数 let Con = [].shift.call(arguments) // 链接到原型 obj.__proto__ = Con.prototype // 绑定 this，执行构造函数 let result = Con.apply(obj, arguments) // 确保 new 出来的是个对象 return typeof result === 'object' ? result : obj&#125; 谈谈小程序的登录授权1.调用 wx.login() 获取 临时登录凭证code ，并回传到开发者服务器。 2.调用 code2Session 接口，换取 用户唯一标识 OpenID 和 会话密钥 session_key。 vue的几种传参方式 props vuex $parent $children provide-inject …项目相关]]></content>
      <tags>
        <tag>面经</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何实现ajax]]></title>
    <url>%2F2020%2F03%2F10%2F2020%2F3%E6%9C%88%2F0310%2F</url>
    <content type="text"><![CDATA[ajax ajax是异步的JavaScript和XML。ajax是一种通过在后台与服务器进行少量数据交换，在无需重新加载整个网页的情况下，更新部分网页的技术 如何实现ajax 创建XMLHttpRequest实例。通过创建一个XMLHttpRequest对象得到一个实例，调用实例的open()方法为这次ajax请求设定相应的HTTP方法，相应的地址以及是否异步。 发送http请求。调用spen()方法发送请求，其可以接收一个参数，既要作为请求主体所发送的数据。 接收服务器相应数据。监听readystatechange事件，通过该实例的readystate属性来判断请求状态，其分为0，1，2，3，4五种状态 属性 描述 onreadystatechange 存储函数（或函数名），每当 readyState 属性改变时，就会调用该函数。 readyState 存有XMLHttpRequest的状态。从0到4发生变化。 0: 请求未初始化 1: 已建立连接 2: 请求已接收 3: 请求处理中 * 4: 请求已完成，且响应已就绪 status 200: “OK”404: 未找到页面 1234567891011121314var xhr;if (window.XMLHttpRequest) &#123; xhr = new XMLHttpRequest();&#125; else &#123; xhr = new ActiveXObject('Microsoft.XMLHTTP');&#125;xhr.onreadystatechange(function() &#123; if (xhr.redayState === 4 &amp;&amp; xhr.status === 200) &#123; console.log(xhr.responseText); console.log(xhr.responseXml); &#125;&#125;)xhr.open('GET', 'www.xxxx.com/xxx/xxx', true);xhr.send(null);]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 观察者模式与发布订阅模式]]></title>
    <url>%2F2020%2F03%2F06%2F2020%2F3%E6%9C%88%2F0306%2F</url>
    <content type="text"><![CDATA[观察者模式观察者模式定义了对象间一种一对多的依赖关系，当目标对象Subject的状态发生改变时，所有依赖它的对象ObServe都会得到通知。 模式特征： 一个目标者对象Subject，拥有方法：添加/删除/通知ObServer； 多个观察者对象ObServe，拥有方法：接收Subject状态变更通知并处理； 目标对象Subject状态变更时，通知所有ObServer。 Subject添加一系列ObServer，Subject负责维护与这些ObServe之间的联系， 代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Subject &#123; constructor() &#123; this.observers = []; // 观察者列表 &#125; // 添加 add(observer) &#123; this.observers.push(observer); &#125; // 删除 remove(observer) &#123; let idx = this.observers.findIndex(item =&gt; item === observer); idx &gt; -1 &amp;&amp; this.observers.splice(idx, 1); &#125;, // 通知 notify() &#123; for (let observer of observers) &#123; observer.update(); &#125; &#125;&#125;class ObServer &#123; constructor(name) &#123; this.name = name; &#125; update() &#123; console.log(`收到通知：$&#123;this.name&#125;`); &#125;&#125;// 实例化目标者let subject = new Subject();// 实例化两个观察者let obs1 = new ObServer('前端开发者');let obs2 = new ObServer('后端开发者');// 向目标者添加观察者subject.add(obs1);subject.add(obs2);// 目标者通知更新subject.notify();// 输出：// 收到通知：前端开发者// 收到通知：后端开发者 优势：目标者与观察者，功能耦合度降低，专注自身功能逻辑；观察者被动接收更新，时间上解耦，实时接收目标者更新状态。缺点：观察者模式虽然实现了对象间依赖关系的低耦合，但却不能对事件通知进行细分管控，如”筛选通知“，”指定主题事件通知“。 发布订阅模式发布订阅模式基于一个事件（主题）通道，希望接收通知的对象Subscriber通过自定义事件订阅主题，被激活事件的对象Publisher通过发布主题事件的方式通知各个订阅该主题的subscriber对象。 代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445// 事件中心let pubSub = &#123; list: &#123;&#125;, // 订阅 subscribe: function(key, fn) &#123; if (!this.list[key]) &#123; this.list[key] = []; &#125; this.list[key].push(fn); &#125;, // 发布 publish: function(key, ...arg) &#123; for (let fn of this.list[key]) &#123; fn.call(this, ...arg); &#125; &#125;, // 取消订阅 unSubscribe: function(key, fn) &#123; let fnList = this.list[key]; if (!fnList) return false; if (!fn) &#123; // 不传入指定取消的订阅方法，则清空所有key下的订阅 fnList &amp;&amp; (fnList.length === 0); &#125; else &#123; fnList.forEach((item, index) =&gt; &#123; if (item === fn) &#123; fnList.splice(index, 1); &#125; &#125;) &#125; &#125;&#125;// 订阅pubSub.subscribe('onwork', time =&gt; &#123; console.log(`上班了：$&#123;time&#125;`);&#125;)pubSub.subscribe('offwork', time =&gt; &#123; console.log(`下班了：$&#123;time&#125;`);&#125;)// 发布pubSub.publish('onwork', '9:00:00');pubSub.publish('offwork', '18:00:00');// 取消订阅pubSub.unSubscribe('onwork'); 发布订阅模式中，订阅者各自实现不同的逻辑，且只接受自己对应的事件通知。实现你想要的 “不一样”。 DOM 事件监听也是 “发布订阅模式” 的应用： 1234567891011121314let loginBtn = document.getElementById('#loginBtn');// 监听回调函数（指定事件）function notifyClick() &#123; console.log('点击');&#125;// 添加事件监听loginBtn.addEventListener('click', notifyClick);// 触发点击，事件中心派发指定事件loginBtn.click();// 取消事件监听loginBtn.removeEventListener('click', notifyClick); 发布订阅的通知顺序： 先订阅后发布时才通知（常规） 订阅后可获取过往以后的发布通知 （QQ离线消息，上线后获取之前的信息） 流行库的应用 jQuery 的 on 和 trigger，$.callback(); Vue 的双向数据绑定； Vue 的父子组件通信 $on/$emit]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[什么是babel?]]></title>
    <url>%2F2020%2F03%2F02%2F2020%2F3%E6%9C%88%2F0302%2F</url>
    <content type="text"><![CDATA[什么是babel?官方的解释 Babel 是一个 JavaScript 编译器，用于将 ECMAScript 2015+ 版本的代码转换为向后兼容的 JavaScript 语法，以便能够运行在当前版本和旧版本的浏览器或其他环境中。简单来说 Babel 的工作就是： 语法转换 通过Polyfill的方式在目标环境中添加缺失的特性 JS源码转换 babel的基本原理原理很简单，核心就是 AST (抽象语法树)。首先将源码转成抽象语法树，然后对语法树进行处理生成新的语法树，最后将新语法树生成新的 JS 代码，整个编译过程可以分为 3 个阶段 parsing (解析)、transforming (转换)、generating (生成)，都是在围绕着 AST 去做文章，话不多说上图： Babel 只负责编译新标准引入的新语法，比如 Arrow function、Class、ES Module 等，它不会编译原生对象新引入的方法和 API，比如 Array.includes，Map，Set 等，这些需要通过 Polyfill 来解决 babel的使用运行babel所需的基本环境 babel/cli babel/core 配置babel babel.config.js .babelrc babelrc.js package.json 四种配置方式作用都一样，你就合着自己的口味来，那种看着顺眼，你就翻它。 插件(Plugins)插件使用来定义如何转换你的代码的。在babel的配置项中填写需要使用的插件名称，babel在编译的时候就会去加载node_modules中对应的npm包，然后编译插件对应的语法。 .babelrc 123456&#123; "plugins": [ "transform-decorators-legacy", "transform-class-properties" ]&#125; 插件执行顺序插件在预设(persets)前运行。 插件的执行顺序是从左往右执行。也就是说在上面的示例中，babel在进行AST遍历的时候会先调用transform-decorators-legacy插件中定义的转换方法，然后再调用transform-class-properties中的方法。 插件传参参数是由插件名称和参数对象组成的一个数组 123456789101112&#123; "plugins": [ [ "import", &#123; "libraryName": "antd", "libraryDirectory": "es", "style": "css" &#125; ], ]&#125; 插件名称插件名称如果为 @babel/plugin-xxx，可以使用短名称@babel/xx，如果为babel-plugin-xx，可以直接使用xx。 自定义插件预设(Presets)预设就是一堆插件(Plugin)的组合，从而达到某种转译的能力，就比如react中使用到的@babel/perset-react，他就是下面几种插件的组合。 @babel/plugin-syntax-jsx @babel/plugin-transform-react-jsx @babel/plugin-transform-react-display-name 当然我们也可以手动的在plugins中配置一系列的plugin来达到目的，就像这样： 1234567&#123; "plugins": [ "@babel/plugin-syntax-jsx", "@babel/plugin-transform-react-jsx", "@babel/plugin-transform-react-display-name" ]&#125; 但是这样一方面显得不那么优雅，另一方面增加了使用者的使用难度。如果直接使用预设就清新脱俗多了~ 12345&#123; "persets": [ "@babel/preset-react" ]&#125; 预设(Presets)的执行顺序前面提到插件的执行顺序是从左往右，而预设的执行顺序恰好反其道行之，它是从右往左。 1234567&#123; "presets": [ "a", "b", "c" ]&#125; 它的执行顺序是 c、b、a，是不是有点奇怪，这主要是为了确保向后兼容，因为大多数用户将 “es2015” 放在 “stage-0” 之前。 自定义预设(Presets)那些她认识你而你不认识她的预设(Presets) @babel/preset-stage-xxx @babel/perset-stage-xxx 是ES在不同阶段语法提案的转码规则而产生的预设，随着被批准为ES新版本的组成部分而进行相应的改变（例如ES6/ES2015）。 提案分为以下几个阶段： stage-0，设想：只是一个想法，可能有babel插件，stage-0的功能范围最广，包含stage-1，stage-2，stage-3的所有功能 stage-1，建议：这是值得跟进的 stage-2，草案：初始规范 stage-3，候选：完成规范并在浏览器上初步实现 stage-4，完成：将添加到下一个年度版本发布中 @babel-preset-es2015 preset-es2015是仅包含ES6功能的Babel预设。 实际上在babel7出来后上面提到的这些预设stage-x，preset-es2015都可以废弃了，因为@bael/preset-env出来一统江湖了。 @babel/preset-env 前面两个预设是从ES标准的维度来确定转码规则的，而@babel/preset-env是根据浏览器的不同版本中缺失的功能确定转换规则的，在配置的时候我们只需要配置需要支持的浏览器版本就好了，@babel/preset-env会根据目标浏览器生成对应的插件列表然后进行编译： 12345678910&#123; "presets": [ ["env", &#123; "targets": &#123; "browser": ["last 10 versions", "ie &gt;= 9"] &#125; &#125;], ], ...&#125; 在默认情况下@babel/preset-env支持将JS目前最新的语法转成ES5，但需要注意的是，如果你代码中用到了还没有成为JS标准的语法，该语法暂时还处于stage阶段，这个时候还是需要安装对应的stage预设，不然编译会报错。 12345678910&#123; "presets": [ ["env", &#123; "targets": &#123; "browsers": ["last 10 versions", "ie &gt;= 9"] &#125; &#125;], ], "stage-0"&#125; 虽然可以采用默认配置，但如果不需要照顾所有的浏览器，还是建议你配置目标浏览器和环境，这样可以保证编译后的代码体积足够小，因为在有的版本浏览器中，新语法本身就能执行，不需要编译。@babel/preset-env 在默认情况下和 preset-stage-x 一样只编译语法，不会对新方法和新的原生对象进行转译，例如： 123const arrFun = ()=&gt;&#123;&#125;const arr = [1,2,3]console.log(arr.includes(1)) 转换后 123456"use strict";var arrFun = function arrFun() &#123;&#125;;var arr = [1, 2, 3];console.log(arr.includes(1)); 箭头函数被转换了，但是 Array.includes 方法，并没有被处理，这个时候要是程序跑在低版本的浏览器上，就会出现 includes is not function 的错误。这个时候就需要 polyfill 闪亮登场了。 Polyfillpolyfill 的翻译过来就是垫片，垫片就是垫平不同浏览器环境的差异，让大家都一样。 @babel/polyfill 模块可以模拟完整的ES5环境。 babel7.4以上版本已经弃用，可以用core-js代替注意 @babel/polyfill 不是在 Babel 配置文件中配置，而是在我们的代码中引入。 12345import '@babel/polyfill';const arrFun = ()=&gt;&#123;&#125;const arr = [1,2,3]console.log(arr.includes(1))Promise.resolve(true) 这样在低版本的浏览器中也能正常运行了。 使用core-js代替，不需要在文件中引入@babel/polyfill 123456789101112131415&#123; "presets": [ "@babel/preset-flow", [ "@babel/preset-env", &#123; "targets": &#123; "node": "8.10" &#125;, "corejs": "3", // 声明 corejs 版本 "useBuiltIns": "usage" &#125; ] ]&#125; ECMAScript 和 JavaScript 的关系ECMAScript 和 JavaScript 的关系是，前者是后者的规格，后者是前者的一种实现。]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[判断数据类型的几种方式]]></title>
    <url>%2F2020%2F02%2F28%2F2020%2F2%E6%9C%88%2F0228%2F</url>
    <content type="text"><![CDATA[判断数据类型1. typeof返回数据类型，包含这7种： number、boolean、symbol、string、object、undefined、function。 引用类型，除了function返回function类型外，其他均返回object。 其中，null 有属于自己的数据类型 Null ， 引用类型中的 数组、日期、正则 也都有属于自己的具体类型，而 typeof 对于这些类型的处理，只返回了处于其原型链最顶端的 Object 类型，没有错，但不是我们想要的结果。 2. Object.prototype.toString.call()toString() 是 Object 的原型方法，调用该方法，默认返回当前对象的 [[Class]] 。这是一个内部属性，其格式为 [object Xxx] ，其中 Xxx 就是对象的类型。 对于 Object 对象，直接调用 toString() 就能返回 [object Object] 。而对于其他对象，则需要通过 call / apply 来调用才能返回正确的类型信息。 12345678910111213Object.prototype.toString.call('') ; // [object String]Object.prototype.toString.call(1) ; // [object Number]Object.prototype.toString.call(true) ; // [object Boolean]Object.prototype.toString.call(Symbol()); //[object Symbol]Object.prototype.toString.call(undefined) ; // [object Undefined]Object.prototype.toString.call(null) ; // [object Null]Object.prototype.toString.call(new Function()) ; // [object Function]Object.prototype.toString.call(new Date()) ; // [object Date]Object.prototype.toString.call([]) ; // [object Array]Object.prototype.toString.call(new RegExp()) ; // [object RegExp]Object.prototype.toString.call(new Error()) ; // [object Error]Object.prototype.toString.call(document) ; // [object HTMLDocument]Object.prototype.toString.call(window) ; //[object global] window 是全局对象 global 的引用 3. constructorconstructor是原型prototype的一个属性，当函数被定义时候，js引擎会为函数添加原型prototype，并且这个prototype中constructor属性指向函数引用， 因此重写prototype会丢失原来的constructor。 不过这种方法有问题：1：null 和 undefined 无constructor，这种方法判断不了。 2：还有，如果自定义对象，开发者重写prototype之后，原有的constructor会丢失，因此，为了规范开发，在重写对象原型时一般都需要重新给 constructor 赋值，以保证对象实例的类型不被篡改。 4. instanceofinstanceof 是用来判断 A 是否为 B 的实例，表达式为：A instanceof B，如果 A 是 B 的实例，则返回 true,否则返回 false。 在这里需要特别注意的是：instanceof 检测的是原型， 由上图可以看出[]的原型指向Array.prototype，间接指向Object.prototype, 因此 [] instanceof Array 返回true， [] instanceof Object 也返回true。 instanceof 只能用来判断两个对象是否属于实例关系， 而不能判断一个对象实例具体属于哪种类型。]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端有哪些页面优化方法?]]></title>
    <url>%2F2020%2F02%2F27%2F2020%2F2%E6%9C%88%2F0227%2F</url>
    <content type="text"><![CDATA[前端有哪些页面优化方法? 减少http请求数 从设计实现层面简化页面，减少元素的使用 合理设置http缓存 资源合并与压缩 合并css图片，减少请求数的又一个好办法 将外部脚本置底（页面信息加载后在加载） 多图页面使用图片懒加载 在js中尽量减少闭包的使用 尽量合并css和js文件 尽量使用字体图标或者svg图标，来代替传统的png等格式图片 减少对dom的操作 尽可能使用事件委托（事件代理）来处理事件绑定的操作 移动端的兼容问题 给移动端添加点击事件会有300S的延迟 如果用点击事件，需要引一个fastclick.js文件，解决300s的延迟 一般在移动端用ontouchstart、ontouchmove、ontouchend 移动端点透问题,touchstart 早于 touchend 早于click,click的触发是有延迟的，这个时间大概在300ms左右，也就是说我们tap触发之后蒙层隐藏， 此时 click还没有触发，300ms之后由于蒙层隐藏，我们的click触发到了下面的a链接上尽量都使用touch事件来替换click事件。例如用touchend事件(推荐)。用fastclick，github.com/ftlabs/fast…用preventDefault阻止a标签的click消除 IE10 里面的那个叉号input:-ms-clear{display:none;} 设置缓存 手机页面通常在第一次加载后会进行缓存，然后每次刷新会使用缓存而不是去重新向服务器发送请求。如果不希望使用缓存可以设置no-cache。 圆角BUG 某些Android手机圆角失效 background-clip: padding-box; 防止手机中网页放大和缩小 这点是最基本的，做为手机网站开发者来说应该都知道的，就是设置meta中的viewport 设置用户截止缩放，一般写视口的时候就已经写好了。]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[call bind apply的区别？js垃圾回收]]></title>
    <url>%2F2020%2F02%2F26%2F2020%2F2%E6%9C%88%2F0226%2F</url>
    <content type="text"><![CDATA[call bind apply的区别？ call() 和 apply()的第一个参数相同，就是指定的对象。这个对象就是该函数的执行上下文。 call()和apply()的区别就在于，两者之间的参数。 call()在第一个参数之后的后续所有参数就是传入该函数的值 apply()只有两个参数，第一个是对象，第二个是数组，这个数组就是该函数的参数。bind()方法和前两者不同在于：bind()方法会返回执行上下文被改变的函数而不会立即执行，而前两者是直接执行该函数。他的参数和call()相同. js垃圾回收JavaScript中的内存管理是自动执行的，而且是不可见的。我们创建基本类型、对象、函数….所有这些都需要内存.当不再需要某样东西时会发生什么? JavaScript 引擎是如何发现并清理它? 1）问什么是垃圾 一般来说没有被引用的对象就是垃圾，就是要被清除， 有个例外如果几个对象引用形成一个环，互相引用，但根访问不到它们，这几个对象也是垃圾，也要被清除。 2）如何检垃圾 一种算法是标记 标记-清除 算法]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css问题]]></title>
    <url>%2F2020%2F02%2F25%2F2020%2F2%E6%9C%88%2F0225%2F</url>
    <content type="text"><![CDATA[css问题用纯css创建一个三角形123456789101112131415&lt;head&gt; &lt;style&gt; div &#123; width: 0; height: 0; border-top: 40px solid transparent; border-left: 40px solid transparent; border-right: 40px solid transparent; border-bottom: 40px solid #ff0000; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;&lt;/div&gt;&lt;/body&gt; 如何理解css的盒模型 标准盒子模型：宽度=内容的宽度（content）+ border + padding低版本IE盒子模型：宽度=内容宽度（content+border+padding) box-sizing属性 content-box：默认值。这是 CSS2.1 指定的宽度和高度的行为。指定元素的宽度和高度（最小/最大属性）适用于box的宽度和高度。元素的填充和边框布局和绘制指定宽度和高度除外。 border-box： 指定宽度和高度（最小/最大属性）确定元素边框。也就是说，对元素指定宽度和高度包括了 padding 和 border 。通过从已设定的宽度和高度分别减去边框和内边距才能得到内容的宽度和高度。 inherit： 指定 box-sizing 属性的值，应该从父元素继承 浏览器的兼容性问题大多数浏览器都会按照上面的图示来呈现内容。然而 IE 5 和 6 的呈现却是不正确的。根据 W3C 的规范，元素内容占据的空间是由 width 属性设置的，而内容周围的 padding 和 border 值是另外计算的。不幸的是，IE5.X 和 6 在怪异模式中使用自己的非标准模型。这些浏览器的 width 属性不是内容的宽度，而是内容、内边距和边框的宽度的总和。 如何清除浮动？ clear清除浮动（添加空div法）在浮动元素下方添加空div,并给该元素写css样式 {clear:both;height:0;overflow:hidden;} 给浮动元素父级设置高度 父级同时浮动（需要给父级同级元素添加浮动） 父级设置成inline-block，其margin: 0 auto居中方式失效 给父级添加overflow:hidden 清除浮动方法 万能清除法 after伪类 清浮动（现在主流方法，推荐使用） 1234567891011div &#123; zoom: 1; &amp;:after &#123; content: ''; clear: both; display: block; height: 0; overflow: hidden; visibility: hidden; &#125;&#125;]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[谈谈你对Redux的理解]]></title>
    <url>%2F2020%2F02%2F24%2F2020%2F2%E6%9C%88%2F0224%2F</url>
    <content type="text"><![CDATA[谈谈你对Redux的理解使用Redux应该遵循的原则： 整个应用共享的state应该存储在store的状态树中，store是唯一的 state不能直接修改，只能通过action表达修改的意图，调用dispatch()修改state state的修改规则reducers必须是一个纯函数，不能有副作用 Redux提供的API createStorecreateStore的作用就是创建一个Redux，store用来存放应用中所有的statecreateStore(reducer, [perloadState], [enhancer])createStore方法接受3个参数，后面两个是可选参数reducer: 参数的类型必须是functionperloadState: 这个参数代表初始化的state(initialState), 可以是任意类型的参数enhancer: 这个参数代表添加的各种中间件，参数的类型必须是function combineReducerscombineReducers主要是把多个reducer合并成一个，并且返回一个新的reducer函数，该函数接收的参数也是两个state和action compose主要是在中间件时候使用，合成函数compose(applyMiddleware(thunk), window.devToolsExtension ? window.devToolsExtension() : undefined) applyMiddleware bindActionCreatorbindActionCreator的主要作用就是将aciton与dispatch函数绑定，生成直接可以出发action的函数 从输入URL到页面加载的全过程 首先，在浏览器地址中输入url 浏览器先查看浏览器缓存-系统缓存-路由器缓存，如果缓存中有，会直接在屏幕中显示页面内容。若没有，则跳到第三步操作 浏览器向DNS（Domain Name System）服务器请求解析该URL中的域名对应的IP地址 解析出IP地址后，根据该IP地址和默认端口80，和服务器建立TCP连接 浏览器发出读取文件（URL中域名后面部分对应的文件）的HTTP请求，该请求报文作为TCP三次握手的第三个报文的数据发送给服务器 服务器对浏览器请求做出响应，并把对应的html文本发送给浏览器 释放TCP连接 浏览器将该html文本并显示内容 重绘（Repaint） &amp; 回流（重排Reflow） 重绘(repaint)：当我们对DOM的修改导致的样式变化，但未影响几何属性时，浏览器不需要重新计算元素的几何属性，直接可以为该元素绘制新的样式，跳过了回流环节，这个过程就叫重绘。 回流（重排 reflow）：对DOM树进行渲染，只要修改DOM或修改元素的形状大小，就会触发reflow，reflow的时候，浏览器会使已渲染好受到影响的部分失效，并重新构造这部分，完成reflow后，浏览器会重新绘制受影响的部分到屏幕中 回流必定会发生重绘，重绘不一定发生回流 12345678910// 触发Reflow增加、删除、修改DOM节点时，会导致Reflow或Repaint移动DOM的位置，或是搞个动画的时候修改CSS样式的时候（宽、高、内外边距、边框等）Resize窗口的时候（移动端没有这个问题），或是滚动的时候改变元素内容（文本或图片等）修改网页的默认字体时// 触发RepaintDOM改动CSS改动 如何减少回流、重绘？减少回流、重绘就是减少对DOM的操作 1.直接改变className，如果动态改变样式，则使用cssText（减少设置多项内联样式） 2.让要操作的元素进行“离线处理”，处理完后一起更新 当使用DocumentFragment进行缓存操作，引发一次回流和重绘 使用display:none 技术，只引发两次回流和重绘 使用cloneNode(true or false)和replaceChild技术，引发一次回流和重绘 3.不要经常访问会引起浏览器flush队列的属性，如果你确实要访问，利用缓存 4.让元素脱离动画流，减少render 树的规模 5.牺牲平滑度换取速度 6.避免使用table布局 7.IE中避免使用javascript表达式 跨域通信的几种方式 JSONP（只支持get请求） window + hash window + domain window + name postMessage WebSocket CORS（Cross-origin resource sharing）跨域资源共享（所有的HTTP请求） nginx反向代理 http-proxy服务端代理请求 前端错误类 即时运行错误：代码错误；捕获方式：try…catch…、window.onerror 资源加载错误；object.onerror（不会冒泡 ）、performance.getEntries、Error事件捕获 浅拷贝 循环遍历 123456789101112131415161718const arr1 = [1, 2, ['ming', 'abc'], 5];const shallowClone = (arr) =&gt; &#123; const dst = []; for (let prop in arr) &#123; if (arr.hasOwnProperty(prop)) &#123; dst[prop] = arr[prop]; &#125; &#125; return dst;&#125;const arr2 = shallowClone(arr1);arr2[2].push('wuhan');arr2[3] = 5;console.log(arr1); [1, 2, ['ming', 'abc', 'wuhan'], 5]console.log(arr2); [1, 2, ['ming', 'abc', 'wuhan'], 5] object.assign() Array.prototype.concat() Array.prototype.slice() obj展开运算符 深拷贝 手动递归 1234567891011121314151617181920212223242526272829303132333435363738function deepClone (sourceObj, targetObj) &#123; let cloneObj = targetObj || &#123;&#125; if(!sourceObj || typeof sourceObj !== "object" || sourceObj.length === undefined)&#123; return sourceObj &#125; if(sourceObj instanceof Array)&#123; cloneObj = sourceObj.concat() &#125; else &#123; for(let i in sourceObj)&#123; if (typeof sourceObj[i] === 'object') &#123; cloneObj[i] = deepClone(sourceObj[i], &#123;&#125;) &#125; else &#123; cloneObj[i] = sourceObj[i] &#125; &#125; &#125; return cloneObj&#125;let sourceObj = &#123; a: 1, b: &#123; a: 1 &#125;, c: &#123; a: 1, b: &#123; a: 1 &#125; &#125;, d: function() &#123; console.log('hello world') &#125;, e: [1, 2, 3]&#125;let targetObj = deepClone(sourceObj, &#123;&#125;)targetObj.c.b.a = 9console.log(sourceObj)console.log(targetObj) JSON.parse(JSON.stringify()) 1234561.如果json里面有时间对象，则序列化结果：时间对象=&gt;字符串的形式；2.如果json里有RegExp、Error对象，则序列化的结果将只得到空对象 RegExp、Error =&gt; &#123;&#125;；3.如果json里有 function,undefined，则序列化的结果会把 function,undefined 丢失；4.如果json里有NaN、Infinity和-Infinity，则序列化的结果会变成null；5.如果json里有对象是由构造函数生成的，则序列化的结果会丢弃对象的 constructor；6.如果对象中存在循环引用的情况也无法实现深拷贝 lodash函数库 123456789101112131415161718var _= require('lodash');const obj1 = [ 1, 'Hello!', &#123; name:'ming1' &#125;, [ &#123; name:'meng1', &#125; ],]const obj2 = _.cloneDeep(obj1);obj2[0] = 2;obj2[1] = 'Hi!';obj2[2].name = 'ming2'obj2[3][0].name = 'meng2';console.log(obj1);console.log(obj2);]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Symbol的应用场景]]></title>
    <url>%2F2020%2F02%2F20%2F2020%2F2%E6%9C%88%2F0220%2F</url>
    <content type="text"><![CDATA[Symbol的应用场景应用场景1：使用Symbol来作为对象属性名（key）12345678910111213let obj = &#123; [Symbol()]: 'test', a: 1, b: 2,&#125;;Object.keys(obj); // ['a', 'b']for (let p in obj) &#123; console.log(p); // 分别输出: a 和 b&#125;Object.getOwnPropertyNames(obj); // ['a', 'b'] 由上代码可知，Symbol类型的key是不能通过Object.keys()或者for…in来枚举的，它未被包含对象自身的属性名集合（property names）之中。所以，利用该特性，我们可以把一些不需要对外操作和访问的属性使用Symbol来定义。 应用场景2：使用Symbol来替代常量12345678910111213141516171819const TYPE_AUDIO = 'AUDIO'const TYPE_VIDEO = 'VIDEO'const TYPE_IMAGE = 'IMAGE'function handleFileResource(resource) &#123; switch(resource.type) &#123; case TYPE_AUDIO: playAudio(resource) break case TYPE_VIDEO: playVideo(resource) break case TYPE_IMAGE: previewImage(resource) break default: throw new Error('Unknown type of resource') &#125;&#125; 如上面的代码中那样，我们经常定义一组常量来代表一种业务逻辑下的几个不同类型，我们通常希望这几个常量之间是唯一的关系，常量少的时候还算好，但是常量一多，你可能还得花点脑子好好为他们取个好点的名字。 现在有了Symbol，我们大可不必这么麻烦了： 123const TYPE_AUDIO = Symbol()const TYPE_VIDEO = Symbol()const TYPE_IMAGE = Symbol() 应用场景3：使用Symbol定义类的私有属性/方法使用的少 彻底搞懂浏览器Event-loop1. 预备知识1JavaScript的运行机制 (1) 所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。(2) 主线程之外，还存在”任务队列”（task queue）。只要异步任务有了运行结果，就在”任务队列”之中放置一个事件。(3) 一旦”执行栈”中的所有同步任务执行完毕，系统就会读取”任务队列”，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。(4) 主线程不断重复上面的第三步 概况就是：调用栈中的同步任务都执行完毕，栈内被清空了，就代表主线程空闲了，这个时候就会去任务队列中按照顺序读取一个任务放入到栈中执行。每次栈内被清空，都会去读取任务队列有没有任务，有就读取执行，一直循环读取-执行的操作。 1JavaScript中有两种异步任务： 宏任务：script（整体代码），setTimeout、setInterval、setImmediate、I/O、UI rendering 微任务：process.nextTick（Nodejs）、Promise、Object.observe、 MutationObServer 2. 事件循环（event-loop）是什么？主线程从”任务队列”中读取执行事件，这个过程是循环不断的，这个机制被称为事件循环。此机制具体如下：主线程会不断从任务队列中按顺序读取任务执行，每执行一个任务都会检查microtask队列是否为空（执行完一个任务的具体标志是函数执行栈为空），如果不为空则会一次性执行完所有microtask。然后进入下一个循环去任务队列中取下一个任务执行。 当前执行栈执行完毕时会立刻先处理所有微任务队列中的事件, 然后再去宏任务队列中取出一个事件。同一次事件循环中, 微任务永远在宏任务之前执行。 3. 为什么会需要event-loop?因为 JavaScript 是单线程的。单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着。为了协调事件（event），用户交互（user interaction），脚本（script），渲染（rendering），网络（networking）等，用户代理（user agent）必须使用事件循环（event loops）。 node中的event-loop与浏览器之间的差异浏览器和 Node 环境下，microtask 任务队列的执行时机不同 Node 端，microtask 在事件循环的各个阶段之间执行 浏览器端，microtask 在事件循环的 macrotask 执行完之后执行 123456789101112131415161718192021console.log('start')setTimeout(() =&gt; &#123; console.log('timer1') Promise.resolve().then(function() &#123; console.log('promise1') &#125;)&#125;, 0)setTimeout(() =&gt; &#123; console.log('timer2') Promise.resolve().then(function() &#123; console.log('promise2') &#125;)&#125;, 0)Promise.resolve().then(function() &#123; console.log('promise3')&#125;)console.log('end')// 浏览器 start=&gt;end=&gt;promise3=&gt;timer1=&gt;promise1=&gt;timer2=&gt;promise2// node start=&gt;end=&gt;promise3=&gt;timer1=&gt;timer2=&gt;promise1=&gt;promise2]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iframe的优缺点]]></title>
    <url>%2F2019%2F10%2F09%2F2019%2F%E6%B5%85%E8%B0%88iframe%2F</url>
    <content type="text"><![CDATA[iframe的优缺点iframe的优点： iframe能够原封不动的把嵌入的网页展现出来。 如果有多个网页引用iframe，那么你只需要修改iframe的内容，就可以实现调用的每一个页面内容的更改，方便快捷。 网页如果为了统一风格，头部和版本都是一样的，就可以写成一个页面，用iframe来嵌套，可以增加代码的可重用。 如果遇到加载缓慢的第三方内容如图标和广告，这些问题可以由iframe来解决。 iframe的缺点： 会产生很多页面，不容易管理。 iframe框架结构有时会让人感到迷惑，如果框架个数多的话，可能会出现上下、左右滚动条，会分散访问者的注意力，用户体验度差。 代码复杂，无法被一些搜索引擎索引到，这一点很关键，现在的搜索引擎爬虫还不能很好的处理iframe中的内容，所以使用iframe会不利于搜索引擎优化。 很多的移动设备（PDA 手机）无法完全显示框架，设备兼容性差。 iframe框架页面会增加服务器的http请求，对于大型网站不是可取的。 iframe迁移问题以及解决方案 import React, { propTypes } from ‘react’; error: PropTypes is undefined; 出现原因: React在新版本中废弃了集成类似propTypes这种第三方库方案。 解决方案: 新仓库使用的react版本较高，以上方式已被废弃，应使用 1import PropTypes from 'prop-types'; import ‘./style.less’; error: 样式失效问题。 出现原因: 新项目中开启了css-module，需要通过配置:global来声明一个全局class，使其在全局起作用。 解决方案1: 1234567### style.less.content &#123; :global &#123; .items &#123;&#125; &#125;&#125; 12345import styles from './style.less';&lt;div className=&#123;styles.content&#125;&gt; &lt;div className="items"&gt;&lt;/div&gt;&lt;/div&gt; 解决方案2: 1234567# style.less:global &#123; .content &#123; .items &#123;&#125; &#125;&#125; 1234import './style.less';&lt;div className="content"&gt; &lt;div className="items"&gt;&lt;/div&gt;&lt;/div&gt; 推荐使用方案1，可以利用css-module的命名规则减少项目中样式的冲突问题。方案2改动小但是太暴力，非常可能产生样式冲突问题。 comm和components中组件出现不可用情况。 error: 功能不可用情况。 解决方案: 建议直接使用antd替换，需要花上一点时间对应antd api做一定代码重构。(!这块需要仔细效验功能是否正常) ec_fe中使用了Component.contextTypes。 例如： 1234Manage.contextTypes = &#123; history: PropTypes.object.isRequired, store: PropTypes.object.isRequired&#125;; Warning: Failed context type: The context history is marked as required in Connect(ContractReview), but its value is undefined. 解决方案：拆分出去的仓库，react-router版本使用的是4.x，已经不需要像老版本一样一层层传递history或者绑定在Context上共享的方式。 ec_fe中使用了this.props.router等路由api 123456this.props.router.replace(&#123; pathname: `/admin/web/packageconfig/function.html`, query: &#123; id: moduleList[0].f_id, &#125;,&#125;); 错误：index.jsx:59 Uncaught TypeError: Cannot read property ‘replace’ of undefined 解决方案：拆分出去的仓库，react-router版本使用的是4.x，请使用react-router-dom提供的api修改。 1234this.props.history.replace(&#123; pathname: `/packageconfig/funModule`, search: `id=$&#123;moduleList[0].f_id&#125;`,&#125;); 参考资料 浅谈iframe react-router-dom]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NextTick 原理分析]]></title>
    <url>%2F2019%2F06%2F13%2F2019%2FJune%2FNextTick%2FREADME%2F</url>
    <content type="text"><![CDATA[NextTick 原理分析nextTick可以让我们在下次DOM更新循环结束之后执行延迟回调，用于获得更新后的DOM。 在Vue2.4之前都是使用的microtasks，但是microtasks的优先级过高，在某些情况下可能会出现比事件冒泡更快的情况，但如果都是macrotasks又可能会出现渲染的性能问题。所以在新版本中，会默认使用microtasks，但在特殊情况下会使用macrotasks，比如v-on。 对于实现macrotasks，会先判断是否能使用setImmediate，不能的话降级为MessageChannel，以上都不行的话就使用setTimeout。 123456789101112131415161718192021if (typeof setImmediate !== 'undefined' &amp;&amp; isNative(setImmediate)) &#123; macroTimerFunc = () =&gt; &#123; setImmediate(flushCallbacks) &#125;&#125; else if ( typeof MessageChannel !== 'undefined' &amp;&amp; (isNative(MessageChannel) || // PhantomJS MessageChannel.toString() === '[object MessageChannelConstructor]')) &#123; const channel = new MessageChannel() const port = channel.port2 channel.port1.onmessage = flushCallbacks macroTimerFunc = () =&gt; &#123; port.postMessage(1) &#125;&#125; else &#123; macroTimerFunc = () =&gt; &#123; setTimeout(flushCallbacks, 0) &#125;&#125; 以上代码用来判断能不能使用相应的API。 注解 macrotasks（宏任务）： setTimeout, setInterval, setImmediate, I/O, UI rendering microtasks（微任务）： process.nextTick, Promise, MutationObserver]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git的基本操作]]></title>
    <url>%2F2019%2F06%2F09%2F2019%2FJune%2Fgit%2FREADME%2F</url>
    <content type="text"><![CDATA[git Rebase 合并 stash reflog Reset Rebase 合并该命令可以让和 merge 命令得到的结果基本是一致的。 通常使用 merge 操作将分支上的代码合并到 master 中，分支样子如下所示 使用 rebase 后，会将 develop 上的 commit 按顺序移到 master 的第三个 commit 后面，分支样子如下所示 Rebase 对比 merge，优势在于合并后的结果很清晰，只有一条线，劣势在于如果一旦出现冲突，解决冲突很麻烦，可能要解决多个冲突，但是 merge 出现冲突只需要解决一次。 使用 rebase 应该在需要被 rebase 的分支上操作，并且该分支是本地分支。如果 develop 分支需要 rebase 到 master 上去，那么应该如下操作 12345## branch developgit rebase masterget checkout master## 用于将 `master` 上的 HEAD 移动到最新的 commitget merge develop stashstash 用于临时报错工作目录的改动。开发中可能会遇到代码写一半需要切分支打包的问题，如果这时候你不想 commit 的话，就可以使用该命令。 1git stash 使用该命令可以暂存你的工作目录，后面想恢复工作目录，只需要使用 1git stash pop 这样你之前临时保存的代码又回来了 reflogreflog 可以看到 HEAD 的移动记录，假如之前误删了一个分支，可以通过 git reflog 看到移动 HEAD 的哈希值 从图中可以看出，HEAD 的最后一次移动行为是 merge 后，接下来分支 new 就被删除了，那么我们可以通过以下命令找回 new 分支 12git checkout 37d9acagit checkout -b new PS：reflog 记录是时效的，只会保存一段时间内的记录。 Reset如果你想删除刚写的 commit，就可以通过以下命令实现 1git reset --hard HEAD^ 但是 reset 的本质并不是删除了 commit，而是重新设置了 HEAD 和它指向的 branch。 git 常用操作$ git ch(checkout) -b develop 创建开发分支develop $ git push 推送当前分支到远端仓库 $ git st(status) 查看当前分支工作区、暂存区的工作状态 $ git diff diff文件的修改 $ git ci(commit) . 提交本次修改 $ git fetch –all 拉取所有远端的最新代码 $ git merge origin/develop 如果是多人协作，merge同事的修改到当前分支（先人后己原则） $ git merge origin/master 上线之前保证当前分支不落后于远端origin/master，一定要merge远端origin/master到当前分支 $ git push 推送当前分支到远端仓库 $ git merge –no-ff origin/develop 同事review code之后管理员合并origin/develop到远端主干origin/master 👉 HEAD：当前commit引用$ git version git版本 $ git branch 查看本地所有的分支 $ git branch -r 查看所有远程的分支 $ git branch -a 查看所有远程分支和本地分支 $ git branch -d 删除本地branchname分支 $ git branch -m brancholdname branchnewname 重命名分支 $ git branch 创建branchname分支 $ git checkout 切换分支到branchname $ git checkout -b 等同于执行上两步，即创建新的分支并切换到该分支 $ git checkout – xx/xx 撤销本文件的更改 $ git pull origin master:master 将远程origin主机的master分支合并到当前master分支,冒号后面的部分表示当前本地所在的分支 $ git pull origin master –allow-unrelated-histories 允许合并两个不同项目的历史记录 $ git push origin -d 删除远程branchname分支 $ git fetch –p 更新分支 $ git status 查看本地工作区、暂存区文件的修改状态 $ git add xx 把xx文件添加到暂存区去 $ git commit -m ‘ ‘ 提交文件 -m 后面的是注释 $ git commit -am(-a -m) 提交所有的修改，等同于上两步 $ git commit ./xx 等同于git add ./xx + git commit]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从零配置webpack（基于webpack 4 和 babel 7版本）]]></title>
    <url>%2F2019%2F05%2F25%2F2019%2FMay%2FWebpack%2FREADME%2F</url>
    <content type="text"><![CDATA[从零配置webpack（基于webpack 4 和 babel 7版本）webpack 核心概念 Entry: 入口 Module: 模块，webpack中一切皆是模块 Chunk: 代码库，一个chunk由十多个模块组合而成，用于代码合并与分割 Loader: 模块转换器，用于把模块原内容按照需求转换成新内容 Plugin: 扩展插件，在webpack构建流程中的特定时机注入扩展逻辑来改变构建结果或做你想要的事情 Output: 输出结果 webpack 流程webpack启动后会从Entry里配置的Module开始递归解析Entry依赖的所有Module。每找到一个Module，就会根据配置的Loader去找出对应的转换规则，对Module进行转换后，再解析出当前的Module依赖的Module。这些模块会以Entry为单位进行分组，一个Entry和其所有依赖的Module被分到一个组也就是一个Chunk。最好Webpack会把所有Chunk转换成文件输出。在整个流程中Webpack会在恰当的时机执行Plugin里定义的逻辑。 最简webpack配置首先初始化npm和安装webpack的依赖： 12npm init -yyarn add webpack webpack-cli --dev 配置webpack.config.js文件： 12345678910const path = require('path');module.export = &#123; entry: path.resolve(__dirname, 'src/index.js'), output: &#123; path: path.resolve(__dirname, 'dist'), filename: 'bundle.js', // 此处不设置，默认为 main.js publicPath: '/' &#125;&#125; 说明: publicPath上线时配置的是cdn的地址。 使用命令进行打包： 1webpack --mode production 也可以将其配置到package.json中的 scripts 字段。入口文件为src/index.js，打包输出到dist/bundle.js。 使用模板htmlhtml-webpack-plugin 可以指定 template 模板文件，将会在 output 目录下，生成 html 文件，并引入打包后的js。安装依赖： 1yarn add html-webpack-plugin --dev 在 webpack.config.js 增加 plugins 配置： 12345678910const HtmlWebpackPlugin = require('html-webpack-plugin');module.exports = &#123; // ... other code plugins: [ new HtmlWebpackPlugin(&#123; template: path.resolve(__dirname, 'src/index.html') &#125;) ]&#125; HtmlWebpackPlugin 还有一些其他的参数，如title（html的title），minify（是否要压缩），filename（dist中生成的html文件名）等。 配置 webpack-dev-serverwebpack-dev-server 提供了一个简单的Web服务器和实时热更新的能力。安装依赖： 1yarn add webpack-dev-server --dev 在 webpck.config.js 增加 devServer 配置： 12345678910const WebpackDevServer = require('webpack-dev-server');module.exports = &#123; // ... other code devServer: &#123; contentBase: './dist', port: '8080', host: 'localhost' &#125;&#125; 在 package.json 的 scripts 字段中增加： 1dev: 'webpack-dev-server --mode development' 之后，我们就可以通过 npm run dev，来启动服务。更多关于 webpack-dev-server 支持加载 css 文件通过使用不同的 style-loader 和 css-loader，可以将 css 文件转换成js文件类型。安装依赖： 1yarn add style-loader css-loader --dev 在 webpack.config.js 中增加 loader 的配置。 12345678910111213module.exports = &#123; // ...other code module: &#123; rules: [ &#123; test: /\.css/, use: ['style-loader', 'css-loader'], exclude: /node_module/, include: path.resolve(__dirname, 'src') &#125; ] &#125;&#125; loader 可以配置以下参数： test: 匹配处理文件的扩展名的正则表达式 use: loader的名称 include/exclude: 手动指定必须处理的文件夹或屏蔽不需要处理的文件夹 query: 为loader提供额外的设置选项 如果需要给loader传参，那么可以使用use + loading的方式，如： 12345678910111213141516171819module.exports = &#123; // other code module: &#123; rules: [ &#123; use: [ &#123; loader: 'style-loader', options: &#123; insertAt: 'top' &#125; &#125;, 'css-loader' ], // ... &#125; ] &#125;&#125; 支持加载图片 file-loader: 解决css等文件中的引入图片路径问题 url-loader: 当图片小于limit的时候会把图片base64编码，大于limit参数的时候还是使用file-loader进行拷贝 如果希望图片存放在单独的目录下，那么需要制定outputPath 安装依赖： 1yarn add url-loader file-loader --dev 在 webpack.config.js 中增加loader的配置（增加在 module.rules的数组中）。 12345678910111213141516171819module.exports = &#123; // ...other code module: &#123; rules: [ &#123; test: /\.(gif|jpg|png|bmp|eot|woff|woff2|ttf|svg)/, use: [ &#123; loader: 'url-loader', options: &#123; limit: 8192, outputPath: 'images' &#125; &#125; ] &#125; ] &#125;&#125; 支持编译less和sass现在大家都习惯使用less或者sass编写css，那么也需要在webpack中进行配置。安装对应的依赖： 12yarn add less less-loader --devyarn add sass sass-loader --dev 在 webpack.config.js 中增加 loader 的配置（module.rules数组中）。 12345678910111213141516171819module.exports = &#123; // .. other code module: &#123; rules: [ &#123; test: /\.less/, use: ['style-loader', 'css-loader', 'less-loader'], exclude: /node_modules/, include: path.resolve(__dirname, 'src') &#125;, &#123; test: /\.scss/, use: ['style-loader', 'css-loader', 'sass-loader'], exclude: /nodu_modules/, include: path.resolve(__dirname, 'src') &#125; ] &#125;&#125; 支持转义 ES6/ES7/JSXES6/ES7/JSX 转义需要 Babel 的依赖，支持装饰器 1yarn add @babel/core babel-loader @babel/preset-env @babel/preset-react @babel/plugin-proposal-decorators @babel/plugin-proposal-object-rest-spread --dev 在 webpack.config.js 中增加 loader 的配置（module.rules 数组中）。 123456789101112131415161718192021module.exports = &#123; // ...other code module: &#123; rules: [ test: /\.jsx?$/, use: [ &#123; loader: 'babel-loader', options: &#123; presets: ['@babel/react'], plugins: [ ['@babel/plugin-proposal-decorators', &#123;'legacy': true&#125;] ] &#125; &#125; ], exclude: /nodu_modules/, include: path.resolve(__dirname, 'src') ] &#125;&#125; 压缩js文件安装依赖： 1yarn add uglifyjs-webpack-plugin --dev 在 webpack.config.js 中增加 optimization 的配置 123456789101112const UglifyWebpackplugin = require('uglifyjs-webpack-plugin');module.exports = &#123; // ... other code optimization: &#123; minimizer: [ new UglifyWebpackPlugin(&#123; parallel: 4 &#125;) ] &#125;&#125; 以上最新版webpack已经默认开启uglifyjs，不需要单独安装plugins但是它是单线程压缩的，我们还可以利用webpack-parallel-uglify-plugin，解决多个js打包并行压缩的需要，优化打包效率 1yarn add webpack-parallel-uglify-plugin --dev 在 webpack.config.js 中增加： 12345678910111213141516171819const WebpackParallelUglifyPlugin = require('webpack-parallel-uglify-plugin');module.exports = &#123; // other code plugins: [ new WebpackParallelUglifyPlugin(&#123; ugfilyJS: &#123; output: &#123; beautify: false, // 是否保留空格和制表符 comments: false, // 是否保留注释 &#125;, compress: &#123; warnings: false, // 删除没有用到的代码时的警告信息, drop_console: true, // 是否删除代码中的console语句 &#125; &#125; &#125;) ]&#125; 分离css（如果css文件较大的话）因为CSS的下载和JS可以并行，当一个html文件很大的时候，可以把css单独提取出来加载 1yarn add mini-css-extract-plugin --dev 在 webpack.config.js 中增加 plugins 的配置，并且将 ‘style-loader’ 修改为 { loader: MiniCssExtractPlugin.loader}。css打包在单独的目录，那么配置filename。 12345678910111213141516171819202122232425262728293031323334353637383940414243const MiniCssExtractPlugin = require('mini-css-extract-plugin');module.exports = &#123; module: &#123; rules: [ &#123; test: /\.css/, use: [ &#123; loader: MiniCssExtractPlugin.loader, &#125;, 'css-loader' ], exclude: /node_modules/, include: path.resolve(__dirname, 'src') &#125;, &#123; test: /\.less/, use: [ &#123; loader: MiniCssExtractPlugin.loader, &#125;, 'css-loader', 'less-loader' ], exclude: /node_modules/, include: path.resolve(__dirname, 'src') &#125;, &#123; test: /\.sass/, use: [ &#123; loader: MiniCssExtractPlugin.loader &#125;, 'css-loader', 'sass-loader' ], exclude: /node_modules/, include: path.resolve(__dirname, 'src') &#125; ] &#125;, plugins: [ new MiniCssExtractPlugin(&#123; filename: 'css/[name].css' &#125;) ]&#125; 压缩css文件安装依赖： 1yarn add optimiza-css-assets-webpack-plugin --dev 在 webpack.config.js 中的 optimization 中增加配置 12345678910const OptimizaCssAssetsWebpackPlugin = require('optimiza-css-assets-webpack-plugin');module.exports = &#123; // ... other code optimization: &#123; minimizer: [ new OptimizaCssAssetsWebpackPlugin() ] &#125;&#125; 打包前先清空输出目录1yarn add clean-webpack-plugin --dev 在 webpack.config.js 中增加 plugins 的配置 12345678const CleanWebpackPlugin = require('clean-webpack-plugin');module.exports = &#123; // ...other code plugins: [ new CleanWebpackPlugin() ]&#125;]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[This]]></title>
    <url>%2F2019%2F05%2F17%2F2019%2FMay%2FThis%2FREADME%2F</url>
    <content type="text"><![CDATA[this 默认绑定 隐式绑定 硬绑定 new绑定 默认绑定默认绑定，在不能应用其他绑定规则时使用的默认规则，通常是独立函数调用。 12345function sayHi() &#123; console.log('Hello', this.name);&#125;var name = 'achen';sayHi(); 在调用sayHi()时，应用了默认绑定，this指向全局对象（非严格模式下），严格模式下，this指向undefined，undefined上没有this对象，会抛出错误。上面的代码，如果在浏览器环境中运行，那么结果是 Hello, achen但是如果在node环境中运行，结果就是Hello, undefined，这是因为node中name并不是挂在全局对象上的。 隐式绑定函数的调用是在某个对象上触发的，即调用位置上存在上下文对象。典型的形式为 XXX.fun()。 123456789function sayHi() &#123; console.log('Hello', this.name);&#125;var person = &#123; name: 'achen', sayHi: sayHi&#125;;var name = 'achenjs';persin.sayHi(); 硬绑定（显示绑定）通过call，apply，bind的方式，显示的指定this所指向的对象。call，apply，bind的第一个参数，就是对应函数的this所指向的对象。call和apply的作用一样，只是传参方式不同。call和apply都会执行对应的函数，而bind方法不会。 12345678910function sayHi() &#123; console.log('Hello', this.name);&#125;var person = &#123; name: 'YvetteLau', sayHi: sayHi&#125;var name = 'Wiliam';var Hi = person.sayHi;Hi.call(person); // Hi.apply(person) new绑定 使用new来调用函数，会自动执行下面的操作： 创建一个新对象 将构造函数的作用域赋值给新对象，即this指向这个新对象 执行构造函数中的代码 返回新对象 12345function SayHi(name) &#123; this.name = name;&#125;var Hi = new SayHi('achen');console.log(Hi.name); // achen 输出结果为achen，原因是因为在var Hi = new SayHi(‘achen’); 这一步，会将SayHi中的this绑定到Hi对象上。 绑定优先级new绑定 &gt; 显示绑定 &gt; 隐式绑定 &gt; 默认绑定 绑定另外如果我们将null或者undefined作为this的绑定对象传入call、apply或者是bind，这些值在调用时会被忽略，实际应用的是默认绑定规则。 12345678var foo = &#123; name: 'Selina',&#125;var name = 'Chirs';function bar() &#123; console.log(this.name);&#125;bar.call(null); // Chirs 箭头函数箭头函数是ES6中新增的，它和普通函数有一些区别，箭头函数没有自己的this，它的this继承于外层代码库中的this。箭头函数在使用中，需要注意以下几点： 函数体内的this对象，继承的是外层代码块的this。 不可以当做构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。 不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用rest参数代替。 不可以使用yield命令，因此箭头函数不能用作Generator函数。 箭头函数没有自己的this，所以不能用call、apply、bind这些方法改变this的指向。 12345678910111213141516171819202122232425var obj = &#123; hi: function() &#123; console.log(this); return () =&gt; &#123; console.log(this); &#125; &#125;, sayHi: function() &#123; return function() &#123; console.log(this); return () =&gt; &#123; console.log(this); &#125; &#125; &#125;, say: () =&gt; &#123; console.log(this); &#125;&#125;;let hi = obj.hi(); // objhi(); // objlet sayHi = obj.sayHi();let fun1 = sayHi(); // windowfun1(); // windowobj.say(); // window]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实现一个promise]]></title>
    <url>%2F2019%2F05%2F15%2F2019%2FMay%2FPromise%2FmyPromise%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970const PENDING = 'PENDING';const RESOLVED = 'RESOLVED';const REJECTED = 'REJECTED';function MyPromise(fn) &#123; const that = this; that.value = null; that.state = PENDING; that.resolvedCallbacks = []; that.rejectedCallbacks = []; function resolve(value) &#123; if (value instanceof MyPromise) &#123; return value.then(resolve, reject); &#125; if (that.state === PENDING) &#123; that.state = RESOLVED; that.value = value; that.resolvedCallbacks.map(cb =&gt; cb(that.value)); &#125; &#125; function reject(value) &#123; if (that.state === PENDING) &#123; that.state = REJECTED; that.value = value; that.rejectedCallbacks.map(cb =&gt; cb(that.value)); &#125; &#125; try &#123; fn(resolve, reject); &#125; catch(e) &#123; reject(e); &#125;&#125;MyPromise.prototype.then = function(onFulfilled, onRejected) &#123; const that = this; onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : v =&gt; v; onRejected = typeof onRejected === 'function' ? onRejected : r =&gt; &#123; throw r &#125;; if (that.state === PENDING) &#123; that.resolvedCallbacks.push(onFulfilled); that.rejectedCallbacks.push(onRejected); &#125; if (that.state === RESOLVED) &#123; onFulfilled(that.value); &#125; if (that.state === REJECTED) &#123; onRejected(that.value); &#125; return that;&#125;new MyPromise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(111); &#125;, 0);&#125;).then(value =&gt; &#123; console.log(value);&#125;).then(value =&gt; &#123; console.log(value);&#125;)]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何写一个jQuery插件]]></title>
    <url>%2F2019%2F05%2F13%2F2019%2FMay%2FJqPlugin%2FREADME%2F</url>
    <content type="text"><![CDATA[如何写一个jQuery插件jQuery 插件开发模式jQuery的插件开发模式主要有三种： 通过$.extend()来扩展jQuery 通过$.fn向jQuery添加新的方法 通过$.widget()应用jQuery UI的部件工厂方式创建 $.extend()1234567891011121314$.fn.extend(&#123; check: function() &#123; return this.each(function() &#123; this.checked = true; &#125;), &#125; uncheck: function() &#123; return this.each(function() &#123; this.checked = false; &#125;) &#125;&#125;)$("input[type='checkbox']").check(); $.fn12345678910function myPlugin($ele, options) &#123;&#125;;myPlugin.prototype = &#123; method1: function() &#123;&#125;, method2: function() &#123;&#125;,&#125;;$.fn.myplugin = function(options) &#123; new myPlugin(this, options);&#125;]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS继承的实现方式]]></title>
    <url>%2F2019%2F05%2F11%2F2019%2FMay%2FExtends%2FREADME%2F</url>
    <content type="text"><![CDATA[JS继承的实现方式1234567891011class Animal &#123; this.name = 'Animal'; this.sleep = function() &#123; console.log(this.name + '~~~'); &#125;&#125;Animal.prototype.eat = function(food) &#123; console.log(this.name + ' eat: ' + food);&#125; 1. 原型链继承核心： 将父类的实例作为子类的原型 12345678910function Cat() &#123;&#125;Cat.prototype = new Animal();Cat.prototype.name = 'cat';var cat = new cat();console.log(cat.name); // catconsole.log(cat.eat('fish')); // cat eat: fishconsole.log(cat.sleep()); // cat~~~console.log(cat instanceof Animal); // trueconsole.log(cat instanceof Cat); // true 特点： 非常纯粹的继承关系，实例是子类的实例，也是父类的实例 父类新增原型方法/原型属性，子类都能访问到 简单，易于实现 缺点： 要想为子类新增属性和方法，必须要在new Animal()这样的语句之后执行，不能放到构造器中 无法实现多继承 来自原型对象的所有属性被所有实例共享 创建子类实例时，无法向父类构造函数传参 2. 构造继承核心：使用父类的构造函数来增强子类实例，等于是复制父类的实例属性给子类（没用到原型） 12345678910function Cat() &#123; Animal.apply(this); // Animal.call(this); this.name = 'cat';&#125;var cat = new Cat();console.log(cat.name); // catconsole.log(cat.sleep()); // cat~~~console.log(cat instanceof Animal); // falseconsole.log(cat instanceof Cat); // true 特点： 解决了1中，子类实例共享父类引用属性的问题 创建子类实例时，可以向父类传递参数 可以实现多继承（call多个父类对象） 缺点： 实例并不是父类的实例，只是子类的实例 只能继承父类的实例属性和方法，不能继承原型属性/方法 无法实现函数复用，每个子类都有父类实例函数的副本，影响性能 3. 实例继承核心：为父类实例添加新特性，做为子类实例返回 1234567891011function Cat(name) &#123; var instance = new Animal(); instance.name = name || 'Tom'; return instance;&#125;var cat = new Cat();console.log(cat.name); // Tomconsole.log(cat.sleep()); // Tom~~~console.log(cat instanceof Animal); // trueconsole.log(cat instanceof Cat); // false 特点： 不限制调用方式，不管事new 子类（）还是子类（），返回的对象具有相同的效果 缺点： 实例是父类的实例，不是子类的实例 不支持多继承 4. 拷贝继承1234567891011121314function Cat() &#123; var animal = new Animal(); for (var i in animal) &#123; Cat.prototype[i] = animal[i]; &#125; Cat.prototype.name = name || 'Tom';&#125;var cat = new Cat();console.log(cat.name); // Tomconsole.log(cat.sleep()); // Tom~~~console.log(cat instanceof Animal); // falseconsole.log(cat instanceof Cat); // true 特点： 支持多继承 缺点： 效率较低，内存占用高（因为要拷贝父类的属性） 无法获取父类不可枚举的方法（不可枚举方法，不能使用for in 访问到） 5. 组合继承核心：通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用 123456789101112function Cat(name) &#123; Animal.call(this); this.name = name || 'Tom';&#125;Cat.prototype = new Animal();Cat.prototype.constructor = Cat; // 修复Cat的构造函数var cat = new Cat();console.log(cat.name); // Tomconsole.log(cat.sleep()); // Tom~~~console.log(cat instanceof Animal); // trueconsole.log(cat instanceof Cat); // true 特点： 弥补了方式2的缺陷，可以继承实例属性/方法，也可以继承原型属性/方法 既是子类的实例，也是父类的实例 不存在引用属性共享问题 可传参 函数可复用 缺点： 调用了两次父类构造函数，生成了两份实例（子类实例将子类原型上的那份屏蔽了） 6. 寄生组合继承核心：通过寄生方式，砍掉父类的实例属性，这样，在调用两次父类的构造的时候，就不会初始化两次实例方法/属性，避免的组合继承的缺点 12345678910111213141516171819function Cat(name) &#123; Animal.call(this); this.name = name || 'Tom';&#125;(function() &#123; // 创建一个没有实例方法的类 var Super = function() &#123;&#125;; Super.prototype = Animal.prototype; // 将实例作为子类的原型 Cat.prototype = new Super(); Cat.prototype.constructor = Cat; // 修复Cat的构造函数&#125;)();var cat = new Cat();console.log(cat.name); // Tomconsole.log(cat.sleep()); // Tom~~~console.log(cat instanceof Animal); // trueconsole.log(cat instanceof Cat); //true 特点： 堪称完美 缺点： 实现较为复杂]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[修饰器的使用]]></title>
    <url>%2F2019%2F05%2F09%2F2019%2FMay%2FDecorator%2FREADME%2F</url>
    <content type="text"><![CDATA[由于使用了decorator, node不用正常识别，需要使用babel转换 1$ babel-node test.js 1. 类修饰器（只有一个参数）target: 指向类，如果是类型是function，则指向MyFunction.prototype 123456function testable(target) &#123; target.isTestable = false;&#125;@testabelclass MyTestableClass &#123;&#125; 以上代码，@testable就是一个装饰器，它为MyTestableClass这个类添加了一个静态属性isTestable 123456789function testable(isTestable) &#123; return function(target) &#123; target.isTestable = isTestable; target.prototype.name = 'achen'; &#125;&#125;@testabel(false)class MyTestabelClass &#123;&#125; 以上代码，告诉我们@testable何如传递参数，并且如何为类添加原型属性或者方法。 2. 方法修饰器（有三个参数）target: 方法所在的类name: 方法名称descriptor: 描述对象12345678910111213141516171819202122class Math &#123; @log add(a, b) &#123; return a + b; &#125;&#125;function log(target, name, descriptor) &#123; var oldValue = descriptor.value; descriptor.value = function() &#123; console.log(`Calling $&#123;name&#125; with`, arguments); return oldValue.apply(this, arguments); &#125; return descriptor;&#125;const math = new Math();math.add(2, 4); 为什么修饰器不能用于函数？修饰器只能用于类和类的方法，不能用于函数，因为存在函数提升123456789var conuter = 0;var add = function() &#123; counter++;&#125;;@addfunction foo() &#123;&#125;]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[什么是函数柯里化？]]></title>
    <url>%2F2019%2F05%2F07%2F2019%2FMay%2FCurry%2FREADME%2F</url>
    <content type="text"><![CDATA[什么是函数柯里化？实现 sum(1)(2)(3) 返回结果是1,2,3之和函数柯里化：把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数 1234567function sum(a) &#123; return function(b) &#123; return function(c) &#123; return a+b+c; &#125; &#125;&#125; 引申：实现一个curry函数，将普通函数进行柯里化123456789101112131415161718function curry(fn, args = []) &#123; return function() &#123; let rest = [...args, ...arguments]; if (rest.length &lt; fn.length) &#123; return curry.call(this, fn, rest); &#125; else &#123; return fn.apply(this, rest); &#125; &#125;&#125;//testfunction sum(a,b,c) &#123; return a+b+c;&#125;let sumFn = curry(sum);console.log(sumFn(1)(2)(3)); //6console.log(sumFn(1)(2, 3)); //6]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常见的浏览器兼容问题]]></title>
    <url>%2F2019%2F05%2F05%2F2019%2FMay%2FCompatible%2FREADME%2F</url>
    <content type="text"><![CDATA[常见的浏览器兼容问题html中的兼容问题不同浏览器的标签默认的外补丁和内补丁不同 场景：随便写几个标签，不加样式控制的情况下，各自的margin和padding差异较大。 解决方法：上来先消除默认样式* {margin: 0, padding: 0} 块属性标签float后，又有横行的margin的情况下，在IE6显示margin比设置的大（即双倍边距bug） 场景：常见症状是IE6后面的一块被顶到下一行; 解决方法：在float的标签样式控制中加入display: inline-block; 将其转化为行内属性 IE6 中z-index失效 场景：元素的父级元素设置的z-index为1，那么其子级元素再设置z-index时会失效，其层级会继承父级元素的设置，造成某些层级调整上的bug 原因：z-index起作用有个前提，就是元素的position属性要是relative、absolute或者fixed。 解决方案：1. position: relative 改为 position: absolute; 2. 去除浮动; 3. 浮动元素添加position属性（如relative，absolute等）。 在写a标签的样式，写的样式没有效果，其实只是写的样式被覆盖了 正确的a标签顺序：link/visited/hover/active 24位png图片，IE6中不兼容透明底儿 解决方式：1. 使用8位png图片; 2. 为ie6准备一套特殊的图片 js在不同浏览器中的兼容问题事件监听的兼容 IE不支持addEventListener; 解决：给IE使用attachEvent 12345678910111213141516171819var addHandler = function(e, type, handler) &#123; if (e.addEventListener) &#123; e.addEventListener(type, handler, false); &#125; else if (e.attachEvent) &#123; e.attachEvent('on' + type, handler); &#125; else &#123; e['on' + type] = handler; &#125;&#125;var removeHandler = function(e, type, handler) &#123; if (e.removeEventListener) &#123; e.removeEventListener(type, handler, false); &#125; else if (e.detachEvent) &#123; e.detachEvent('on' + type, handler); &#125; else &#123; on['on' + type] = null &#125;&#125; event.targey的兼容，引发事件的DOM元素。 IE 6789不支持event.target 解决方法：event.srcElement; 1target = event.target || event.srcElement; 阻止系统默认的兼容 IE 6789不支持event.preventDefault; 1event.preventDefault ? event.preventDefault() : event.returnValue = false 阻止事件冒泡的兼容 IE 6789不支持event.stopPropagation; 1event.stopPropagation ? event.stopPropagation() : event.cancelBubble = false]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[构造方法constructor]]></title>
    <url>%2F2019%2F05%2F03%2F2019%2FMay%2FClasses%2FREADME%2F</url>
    <content type="text"><![CDATA[构造方法constructor是一种用于创建和初始化class创建的对象的特殊方法。描述 在一个类中只能有一个名叫”constructor”的特殊方法。一个类中出现多次将会抛出SyntaxError错误。 在一个构造方法中可以使用super关键字来调用一个父类的构造方法 如果没有显示指定构造方法，则会添加默认的construtor方法。 如果不指定一个构造函数（constructor）方法，则使用一个默认的构造函数（constructor） 如果不指定构造方法，则使用默认构造函数。对于基类，默认构造函数是： 1constructor() &#123;&#125; 对于派生类，默认构造函数是： 123constructor(...args) &#123; super(...args);&#125; extendsextends关键字用于类声明或者类表达式中，以创建一个类，该类是另一个类的子类。描述 extends关键字用来创建一个普通类或者内建对象的子类继承的.prototype必须是一个Object或者null。 static类（class）通过static关键字定义静态方法。不能在类的实例上调用静态方法，而应该通过类本身调用。这些通常是实用程序方法，例如创建或克隆对象的功能 123456class ClassWithStaticMethod &#123; static staticMethod() &#123; return 'static method has been called.'; &#125;&#125;ClassWithStaticMethod.staticMethod(); 调用静态方法 从另一个静态方法，静态方法调用同一个类中的其他静态方法，可使用this关键字 12345678class StaticMethodCall &#123; static staticMethod() &#123; return 'Static method has been called'; &#125; static anotherStaticMethod() &#123; return this.staticMethod() + ' from another static method'; &#125;&#125; 从类的构造函数和其他方法，非静态方法中，不能直接使用this关键字来访问静态方法。而是要用类名来调用；CLASSNAME.STATIC_METHOD_NAME()，或者用构造函数的属性来调用该方法；this.constructor.STATIC_METHOD_NAME()。 1234567891011class StaticMethodCall &#123; constructor() &#123; console.log(StaticMethodCall.staticMethod()); // 'static method has been called.' console.log(this.constructor.staticMethod()); // 'static method has been called.' &#125; static staticMethod() &#123; return 'static method has been called.'; &#125;&#125; 补充 目前ECMAScript，class中还没有定义Private（私有属性）的能力，所以我们通过约定，用下划线来标记它们。 123456789class Car &#123; _milesDriven = 0; drive(distance) &#123; this._milesDriven += distance; &#125; getMilesDriven() &#123; return this._milesDriven; &#125;&#125; 在上面的事例中，我们依靠Car的实例调用getMilesDriven方法来获取到它的私有属性_milesDriven。但是，因为没有什么能使_milesDriven成为私有的，所以任何实例都可以访问它。 123const tesla = new Cal();tesla.drive(10);console.log(tesla._milesDriven); 目前Class Fields有个提案，我们可以通过#创建私有字段。 1234567891011121314class Car &#123; #milesDriven = 0; drive(distance) &#123; this.#milesDriven += distance; &#125; getMilesDriven() &#123; return this.#milesDriven; &#125;&#125;const tesla = new Car()tesla.drive(10)tesla.getMilesDriven() // 10tesla.#milesDriven // Invalid]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[call、apply有什么区别？call、apply和bind的内部实现]]></title>
    <url>%2F2019%2F05%2F01%2F2019%2FMay%2FBind%2FREADME%2F</url>
    <content type="text"><![CDATA[call、apply有什么区别？call、apply和bind的内部实现call、apply的功能相同，区别在于传参的方式不一样： fn.call(obj, arg1, arg2, …)，调用一个函数，具有一个指定的this值和分别提供的参数（参数的列表）。 fn.apply(obj, [argsArray])，调用一个函数，具有一个指定的this值，以及作为一个数组（或类数组对象）提供参数。 call核心 将函数设为传入参数的属性 指定this到函数并传入给定参数执行函数 如果不传入参数或者参数为null，默认指向为 window/global 删除参数上的函数 123456789101112131415161718192021222324252627282930Function.prototype.call = function(context) &#123; /* * 如果第一个参数传入的是 null 或者 undefined，那么this指向 window/global * 如果第一个参数传入的不是 null 或者 undefined，那么必须是一个对象 */ if (!context) &#123; // context为null或者是undefined // 判断是浏览器环境还是node环境 context = typeof window === 'undefined' ? global : window; &#125; context.fn = this; // this指向是当前的函数（Function的实例） let rest = [...arguments].slice(1); // 获取除了this指向对象以外的参数，空数组slice后返回的仍然是空数组 let result = context.fn(...rest); // 隐式绑定，当前函数的this指向了context delete context.fn; return result;&#125;// test codevar foo = &#123; name: 'Selina'&#125;;var name = 'Chirs';function bar(job, age) &#123; console.log(this.name); console.log(job, age);&#125;bar.call(foo, 'programmer', 20);// Selina programmer, 20bar.call(null, 'teacher', 25);// brower环境： Chirs teacher, 25； node环境： undefined teacher, 25 apply核心apply的实现和call很类似，但是需要注意他们的参数不一样，apply的第二个参数是数组或类数组。 123456789101112131415161718192021222324252627282930313233343536Function.prototype.apply = function(context, rest) &#123; /* * 如果第一个参数传入的是 null 或者 undefined，那么this指向 window/global * 如果第一个参数传入的不是 null 或者 undefined，那么必须是一个对象 */ if (!context) &#123; // context为null或者是undefined // 判断是浏览器环境还是node环境 context = typeof window === 'undefined' ? global : window; &#125; context.fn = this; let result; if (rest == null) &#123; // undefined 或者 null 不是 Iterator 对象，不能被... result = context.fn(rest); &#125; else if (typeof rest === 'object') &#123; result = context.fn(...rest); &#125; delete result.fn; return result;&#125;// test codevar foo = &#123; name: 'Selina'&#125;;var name = 'Chirs';function bar(job, age) &#123; console.log(this.name); console.log(job, age);&#125;bar.apply(foo, ['programmer', 20]);// Selina programmer, 20bar.apply(null, ['teacher', 25]);// brower环境： Chirs teacher, 25； node环境： undefined teacher, 25 bind核心bind 和 call/apply 有一个很重要的区别，一个函数被 call/apply 的时候，会直接调用，但是 bind会创建一个新函数。当这个新函数被调用时，bind()的第一个参数将作为它运行时的this，之后的一系列参数将会在传递的实参前传入作为它的参数。 12345678910111213141516171819202122232425Function.prototype.bind = function(context) &#123; if (typeof this !== 'function') &#123; throw new TypeError('not a function'); &#125; let self = this; let args = [...arguments].slice(1); function Fn() &#123;&#125;; Fn.prototype = this.prototype; let bound = function() &#123; let res = [...args, ...arguments]; // bind传递的参数和函数调用时传递的参数拼接 context = this instanceof Fn ? this : context || this; return self.apply(context, res); &#125; // 原型链 bound.prototype = new Fn(); return bound;&#125;var name = 'Jack';function person(age, job, gender)&#123; console.log(this.name , age, job, gender);&#125;var Yve = &#123;name : 'Yvette'&#125;;let result = person.bind(Yve, 22, 'enginner')('female');]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[fileReader读取文件，实现图片本地预览]]></title>
    <url>%2F2018%2F10%2F09%2FfileReader%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[FileReaderFileReader 对象允许Web应用程序异步读取存储在用户计算机上的文件(或原始数据缓冲区)的内容,使用 File 或 Blob 对象指定要读取的文件或数据。 首先创建一个FileReader实例：1var reader = new FileReader(); 方法 方法 描述 abort() 中止读取操作。在返回时，readyState属性为DONE。 readAsArrayBuffer() 开始读取指定的 Blob中的内容, 一旦完成, result 属性中保存的将是被读取文件的 ArrayBuffer 数据对象. readAsBinaryString() 开始读取指定的Blob中的内容。一旦完成，result属性中将包含所读取文件的原始二进制数据。 readAsDataURL() 开始读取指定的Blob中的内容。一旦完成，result属性中将包含一个data: URL格式的字符串以表示所读取文件的内容 readAsText() 开始读取指定的Blob中的内容。一旦完成，result属性中将包含一个字符串以表示所读取的文件内容。 具体事例input file实现本地图片预览123456789var inputBox = document.getElementById(&quot;inputBox&quot;);inputBox.addEventListener(&quot;change&quot;,function()&#123; var reader = new FileReader(); reader.readAsDataURL(inputBox.files[0]);//发起异步请求 reader.onload = function()&#123; // 读取完成后，base64数据保存在对象的result属性中 console.log(this.result) &#125;&#125;) 引用 FileReader详解]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react-router解读（三）]]></title>
    <url>%2F2018%2F08%2F28%2Freact-router%E8%A7%A3%E8%AF%BB%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[history methods createBrowserHistory通过之前我们已经知道了react-router-dom的 history模式使用的是history库中的createBrowserHistory方法。下面我们来一起看看其中的奥秘。 var createBrowserHistory = function createBrowserHistory() { // arguments[0], 由上一节可知它是一个非必传的object var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}; (0, _invariant2.default)(_DOMUtils.canUseDOM, 'Browser history needs a DOM'); // 之前将history赋值给变量globalHistory var globalHistory = window.history; // _DOMUtils.js 中处理一些浏览器兼容性 和 浏览器内核、机型判断的方法 // 判断是否非主流机型以及浏览器 var canUseHistory = (0, _DOMUtils.supportsHistory)(); // 是否为IE浏览器 var needsHashChangeListener = !(0, _DOMUtils.supportsPopStateOnHashChange)(); // forceRefresh为true，代表将在页面导航时使用完整页面刷新。其他参数请自行参考官网文档 var _props$forceRefresh = props.forceRefresh, forceRefresh = _props$forceRefresh === undefined ? false : _props$forceRefresh, _props$getUserConfirm = props.getUserConfirmation, getUserConfirmation = _props$getUserConfirm === undefined ? _DOMUtils.getConfirmation : _props$getUserConfirm, _props$keyLength = props.keyLength, keyLength = _props$keyLength === undefined ? 6 : _props$keyLength; var basename = props.basename ? (0, _PathUtils.stripTrailingSlash)((0, _PathUtils.addLeadingSlash)(props.basename)) : ''; var getDOMLocation = function getDOMLocation(historyState) { var _ref = historyState || {}, key = _ref.key, state = _ref.state; var _window$location = window.location, pathname = _window$location.pathname, search = _window$location.search, hash = _window$location.hash; var path = pathname + search + hash; (0, _warning2.default)(!basename || (0, _PathUtils.hasBasename)(path, basename), 'You are attempting to use a basename on a page whose URL path does not begin ' + 'with the basename. Expected path "' + path + '" to begin with "' + basename + '".'); if (basename) path = (0, _PathUtils.stripBasename)(path, basename); return (0, _LocationUtils.createLocation)(path, state, key); }; var createKey = function createKey() { return Math.random().toString(36).substr(2, keyLength); }; var transitionManager = (0, _createTransitionManager2.default)(); var setState = function setState(nextState) { _extends(history, nextState); history.length = globalHistory.length; transitionManager.notifyListeners(history.location, history.action); }; var handlePopState = function handlePopState(event) { if ((0, _DOMUtils.isExtraneousPopstateEvent)(event)) return; handlePop(getDOMLocation(event.state)); }; var handleHashChange = function handleHashChange() { handlePop(getDOMLocation(getHistoryState())); }; var forceNextPop = false; var handlePop = function handlePop(location) { if (forceNextPop) { forceNextPop = false; setState(); } else { var action = 'POP'; transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) { if (ok) { setState({ action: action, location: location }); } else { revertPop(location); } }); } }; var revertPop = function revertPop(fromLocation) { var toLocation = history.location; // TODO: We could probably make this more reliable by // keeping a list of keys we've seen in sessionStorage. // Instead, we just default to 0 for keys we don't know. var toIndex = allKeys.indexOf(toLocation.key); if (toIndex === -1) toIndex = 0; var fromIndex = allKeys.indexOf(fromLocation.key); if (fromIndex === -1) fromIndex = 0; var delta = toIndex - fromIndex; if (delta) { forceNextPop = true; go(delta); } }; var initialLocation = getDOMLocation(getHistoryState()); var allKeys = [initialLocation.key]; var createHref = function createHref(location) { return basename + (0, _PathUtils.createPath)(location); }; var push = function push(path, state) { (0, _warning2.default)(!((typeof path === 'undefined' ? 'undefined' : _typeof(path)) === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to push when the 1st ' + 'argument is a location-like object that already has state; it is ignored'); var action = 'PUSH'; // 重写location对象 var location = (0, _LocationUtils.createLocation)(path, state, createKey(), history.location); transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) { if (!ok) return; var href = createHref(location); var key = location.key, state = location.state; if (canUseHistory) { globalHistory.pushState({ key: key, state: state }, null, href); if (forceRefresh) { window.location.href = href; } else { var prevIndex = allKeys.indexOf(history.location.key); var nextKeys = allKeys.slice(0, prevIndex === -1 ? 0 : prevIndex + 1); nextKeys.push(location.key); allKeys = nextKeys; setState({ action: action, location: location }); } } else { (0, _warning2.default)(state === undefined, 'Browser history cannot push state in browsers that do not support HTML5 history'); window.location.href = href; } }); }; var replace = function replace(path, state) { (0, _warning2.default)(!((typeof path === 'undefined' ? 'undefined' : _typeof(path)) === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to replace when the 1st ' + 'argument is a location-like object that already has state; it is ignored'); var action = 'REPLACE'; var location = (0, _LocationUtils.createLocation)(path, state, createKey(), history.location); transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) { if (!ok) return; var href = createHref(location); var key = location.key, state = location.state; if (canUseHistory) { globalHistory.replaceState({ key: key, state: state }, null, href); if (forceRefresh) { window.location.replace(href); } else { var prevIndex = allKeys.indexOf(history.location.key); if (prevIndex !== -1) allKeys[prevIndex] = location.key; setState({ action: action, location: location }); } } else { (0, _warning2.default)(state === undefined, 'Browser history cannot replace state in browsers that do not support HTML5 history'); window.location.replace(href); } }); }; var go = function go(n) { globalHistory.go(n); }; var goBack = function goBack() { return go(-1); }; var goForward = function goForward() { return go(1); }; var listenerCount = 0; var checkDOMListeners = function checkDOMListeners(delta) { listenerCount += delta; if (listenerCount === 1) { (0, _DOMUtils.addEventListener)(window, PopStateEvent, handlePopState); if (needsHashChangeListener) (0, _DOMUtils.addEventListener)(window, HashChangeEvent, handleHashChange); } else if (listenerCount === 0) { (0, _DOMUtils.removeEventListener)(window, PopStateEvent, handlePopState); if (needsHashChangeListener) (0, _DOMUtils.removeEventListener)(window, HashChangeEvent, handleHashChange); } }; var isBlocked = false; var block = function block() { var prompt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false; var unblock = transitionManager.setPrompt(prompt); if (!isBlocked) { checkDOMListeners(1); isBlocked = true; } return function () { if (isBlocked) { isBlocked = false; checkDOMListeners(-1); } return unblock(); }; }; var listen = function listen(listener) { var unlisten = transitionManager.appendListener(listener); checkDOMListeners(1); return function () { checkDOMListeners(-1); unlisten(); }; }; var history = { length: globalHistory.length, action: 'POP', location: initialLocation, createHref: createHref, push: push, replace: replace, go: go, goBack: goBack, goForward: goForward, block: block, listen: listen }; return history; };]]></content>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react-router解读（二）]]></title>
    <url>%2F2018%2F08%2F27%2Freact-router%E8%A7%A3%E8%AF%BB%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[react-router 的路由实现既然知道了这个原理，我们来看下 react-router 的实现，我们打开 react-router 项目地址,把项目克隆下来，或则直接在 github 上预览，在 React 开发的项目里，我们通过 router.push(‘home’) 来实现页面的跳转，所以我们检索下，push 方法的实现 我们检索到了 46个 js 文件，😂，一般到这个时候，我们会放弃源码阅读，那么我们今天的文章就到这结束，谢谢大家！ 开个玩笑，源码阅读不能这么粗糙，react-router 4.x用法，我们只需要安装 react-router-dom。所以我们找到 package 下的 react-router-dom/modules 目录，点开 index.js 文件。 export BrowserRouter from "./BrowserRouter"; export HashRouter from "./HashRouter"; export Link from "./Link"; export MemoryRouter from "./MemoryRouter"; export NavLink from "./NavLink"; export Prompt from "./Prompt"; export Redirect from "./Redirect"; export Route from "./Route"; export Router from "./Router"; export StaticRouter from "./StaticRouter"; export Switch from "./Switch"; export generatePath from "./generatePath"; export matchPath from "./matchPath"; export withRouter from "./withRouter"; 看到 history 对象的实例与配置的 mode 有关，react-router-dom 通过3种方式实现了路由切换。我们今天讲的内容相匹配的是 createBrowserHistory 的实现方案 (另外两个分别是：createHashHistory和createMemoryHistory)。 这里 react-router-dom 将 BrowserRouter、HashRouter、Link 拆分为单独组件实现，也是与 react-router 3 之间的区别之一。详细文档我们来看 react-router-dom 中的 BrowserRouter 源码： import warning from "warning"; import React from "react"; import PropTypes from "prop-types"; import { createBrowserHistory as createHistory } from "history"; import Router from "./Router"; /** * The public API for a that uses HTML5 history. */ class BrowserRouter extends React.Component { static propTypes = { basename: PropTypes.string, forceRefresh: PropTypes.bool, getUserConfirmation: PropTypes.func, keyLength: PropTypes.number, children: PropTypes.node }; history = createHistory(this.props); componentWillMount() { warning( !this.props.history, " ignores the history prop. To use a custom history, " + "use `import { Router }` instead of `import { BrowserRouter as Router }`." ); } render() { return ; } } export default BrowserRouter; 由上可知我们在项目中使用的组件，history方式是使用了一个叫history库中的 createBrowserHistory 方法。 模拟单页面路由通过上面的学习，我们知道了，单页面应用路由的实现原理，我们也尝试去实现一个。在做管理系统的时候，我们通常会在页面的左侧放置一个固定的导航 sidebar，页面的右侧放与之匹配的内容 main 。点击导航时，我们只希望内容进行更新，如果刷新了整个页面，到时导航和通用的头部底部也进行重绘重排的话，十分浪费资源，体验也会不好。这个时候，我们就能用到我们今天学习到的内容，通过使用 HTML5 的 pushState 方法和 replaceState 方法来实现， 思路：首先绑定 click 事件。当用户点击一个链接时，通过 preventDefault 函数防止默认的行为（页面跳转），同时读取链接的地址（如果有 jQuery，可以写成$(this).attr(‘href’)），把这个地址通过pushState塞入浏览器历史记录中，再利用 AJAX 技术拉取（如果有 jQuery，可以使用$.get方法）这个地址中真正的内容，同时替换当前网页的内容。 为了处理用户前进、后退，我们监听 popstate 事件。当用户点击前进或后退按钮时，浏览器地址自动被转换成相应的地址，同时popstate事件发生。在事件处理函数中，我们根据当前的地址抓取相应的内容，然后利用 AJAX 拉取这个地址的真正内容，呈现，即可。 最后，整个过程是不会改变页面标题的，可以通过直接对 document.title 赋值来更改页面标题。 扩展好了,我们今天通过多个方面来讲了 pushState 方法和 replaceState 的应用，你应该对这个两个方法能有一个比较深刻的印象，如果想要了解更多，你可以参考以下链接 history对象]]></content>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react-router解读（一）]]></title>
    <url>%2F2018%2F08%2F27%2Freact-router%E8%A7%A3%E8%AF%BB%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前言前端路由是通过改变URL，在不重新请求页面的情况下，更新页面视图。目前在浏览器环境中这一功能的实现主要有2种: 利用URL中的hash 利用H5中history pushState 和 replaceState 了解一下 history 提供了两个方法，能够无刷新的修改用户的浏览记录，pushSate，和 replaceState，区别的 pushState 在用户访问页面后面添加一个访问记录， replaceState 则是直接替换了当前访问记录 history 对象的详细信息已经有很多很好很详细的介绍文献，这里不再做总结history对象 history.pushStatehistory.pushState方法接受三个参数，依次为： state：一个与指定网址相关的状态对象，popstate事件触发时，该对象会传入回调函数。如果不需要这个对象，此处可以填null。title：新页面的标题，但是所有浏览器目前都忽略这个值，因此这里可以填null。url：新的网址，必须与当前页面处在同一个域。浏览器的地址栏将显示这个网址。假定当前网址是example.com/1.html，我们使用pushState方法在浏览记录（history对象）中添加一个新记录。 var stateObj = { foo: 'bar' }; history.pushState(stateObj, 'page 2', '2.html'); 添加上面这个新记录后，浏览器地址栏立刻显示 example.com/2.html，但并不会跳转到 2.html，甚至也不会检查2.html 是否存在，它只是成为浏览历史中的最新记录。这时，你在地址栏输入一个新的地址(比如访问 google.com )，然后点击了倒退按钮，页面的 URL 将显示 2.html；你再点击一次倒退按钮，URL 将显示 1.html。 总之，pushState 方法不会触发页面刷新，只是导致 history 对象发生变化，地址栏会有反应。 如果 pushState 的 url参数，设置了一个新的锚点值（即hash），并不会触发 hashchange 事件。如果设置了一个跨域网址，则会报错。 // 报错 history.pushState(null, null, 'https://twitter.com/hello'); 上面代码中，pushState想要插入一个跨域的网址，导致报错。这样设计的目的是，防止恶意代码让用户以为他们是在另一个网站上。 history.replaceStatehistory.replaceState 方法的参数与 pushState 方法一模一样，区别是它修改浏览历史中当前纪录,假定当前网页是 example.com/example.html。 history.pushState({page: 1}, 'title 1', '?page=1'); history.pushState({page: 2}, 'title 2', '?page=2'); history.replaceState({page: 3}, 'title 3', '?page=3'); history.back() // url显示为http://example.com/example.html?page=1 history.back() // url显示为http://example.com/example.html history.go(2) // url显示为http://example.com/example.html?page=3]]></content>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello Hexo]]></title>
    <url>%2F2018%2F08%2F24%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
