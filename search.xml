<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JavaScript 观察者模式与发布订阅模式]]></title>
    <url>%2F2020%2F03%2F06%2F2020%2F3%E6%9C%88%2F0306%2F</url>
    <content type="text"><![CDATA[观察者模式观察者模式定义了对象间一种一对多的依赖关系，当目标对象Subject的状态发生改变时，所有依赖它的对象ObServe都会得到通知。 模式特征： 一个目标者对象Subject，拥有方法：添加/删除/通知ObServer； 多个观察者对象ObServe，拥有方法：接收Subject状态变更通知并处理； 目标对象Subject状态变更时，通知所有ObServer。 Subject添加一系列ObServer，Subject负责维护与这些ObServe之间的联系， 代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Subject &#123; constructor() &#123; this.observers = []; // 观察者列表 &#125; // 添加 add(observer) &#123; this.observers.push(observer); &#125; // 删除 remove(observer) &#123; let idx = this.observers.findIndex(item =&gt; item === observer); idx &gt; -1 &amp;&amp; this.observers.splice(idx, 1); &#125;, // 通知 notify() &#123; for (let observer of observers) &#123; observer.update(); &#125; &#125;&#125;class ObServer &#123; constructor(name) &#123; this.name = name; &#125; update() &#123; console.log(`收到通知：$&#123;this.name&#125;`); &#125;&#125;// 实例化目标者let subject = new Subject();// 实例化两个观察者let obs1 = new ObServer('前端开发者');let obs2 = new ObServer('后端开发者');// 向目标者添加观察者subject.add(obs1);subject.add(obs2);// 目标者通知更新subject.notify();// 输出：// 收到通知：前端开发者// 收到通知：后端开发者 优势：目标者与观察者，功能耦合度降低，专注自身功能逻辑；观察者被动接收更新，时间上解耦，实时接收目标者更新状态。缺点：观察者模式虽然实现了对象间依赖关系的低耦合，但却不能对事件通知进行细分管控，如”筛选通知“，”指定主题事件通知“。 发布订阅模式发布订阅模式基于一个事件（主题）通道，希望接收通知的对象Subscriber通过自定义事件订阅主题，被激活事件的对象Publisher通过发布主题事件的方式通知各个订阅该主题的subscriber对象。 代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445// 事件中心let pubSub = &#123; list: &#123;&#125;, // 订阅 subscribe: function(key, fn) &#123; if (!this.list[key]) &#123; this.list[key] = []; &#125; this.list[key].push(fn); &#125;, // 发布 publish: function(key, ...arg) &#123; for (let fn of this.list[key]) &#123; fn.call(this, ...arg); &#125; &#125;, // 取消订阅 unSubscribe: function(key, fn) &#123; let fnList = this.list[key]; if (!fnList) return false; if (!fn) &#123; // 不传入指定取消的订阅方法，则清空所有key下的订阅 fnList &amp;&amp; (fnList.length === 0); &#125; else &#123; fnList.forEach((item, index) =&gt; &#123; if (item === fn) &#123; fnList.splice(index, 1); &#125; &#125;) &#125; &#125;&#125;// 订阅pubSub.subscribe('onwork', time =&gt; &#123; console.log(`上班了：$&#123;time&#125;`);&#125;)pubSub.subscribe('offwork', time =&gt; &#123; console.log(`下班了：$&#123;time&#125;`);&#125;)// 发布pubSub.publish('onwork', '9:00:00');pubSub.publish('offwork', '18:00:00');// 取消订阅pubSub.unSubscribe('onwork'); 发布订阅模式中，订阅者各自实现不同的逻辑，且只接受自己对应的事件通知。实现你想要的 “不一样”。 DOM 事件监听也是 “发布订阅模式” 的应用： 1234567891011121314let loginBtn = document.getElementById('#loginBtn');// 监听回调函数（指定事件）function notifyClick() &#123; console.log('点击');&#125;// 添加事件监听loginBtn.addEventListener('click', notifyClick);// 触发点击，事件中心派发指定事件loginBtn.click();// 取消事件监听loginBtn.removeEventListener('click', notifyClick); 发布订阅的通知顺序： 先订阅后发布时才通知（常规） 订阅后可获取过往以后的发布通知 （QQ离线消息，上线后获取之前的信息） 流行库的应用 jQuery 的 on 和 trigger，$.callback(); Vue 的双向数据绑定； Vue 的父子组件通信 $on/$emit]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[什么是babel?]]></title>
    <url>%2F2020%2F03%2F02%2F2020%2F3%E6%9C%88%2F0302%2F</url>
    <content type="text"><![CDATA[什么是babel?官方的解释 Babel 是一个 JavaScript 编译器，用于将 ECMAScript 2015+ 版本的代码转换为向后兼容的 JavaScript 语法，以便能够运行在当前版本和旧版本的浏览器或其他环境中。简单来说 Babel 的工作就是： 语法转换 通过Polyfill的方式在目标环境中添加缺失的特性 JS源码转换 babel的基本原理原理很简单，核心就是 AST (抽象语法树)。首先将源码转成抽象语法树，然后对语法树进行处理生成新的语法树，最后将新语法树生成新的 JS 代码，整个编译过程可以分为 3 个阶段 parsing (解析)、transforming (转换)、generating (生成)，都是在围绕着 AST 去做文章，话不多说上图： Babel 只负责编译新标准引入的新语法，比如 Arrow function、Class、ES Module 等，它不会编译原生对象新引入的方法和 API，比如 Array.includes，Map，Set 等，这些需要通过 Polyfill 来解决 babel的使用运行babel所需的基本环境 babel/cli babel/core 配置babel babel.config.js .babelrc babelrc.js package.json 四种配置方式作用都一样，你就合着自己的口味来，那种看着顺眼，你就翻它。 插件(Plugins)插件使用来定义如何转换你的代码的。在babel的配置项中填写需要使用的插件名称，babel在编译的时候就会去加载node_modules中对应的npm包，然后编译插件对应的语法。 .babelrc 123456&#123; "plugins": [ "transform-decorators-legacy", "transform-class-properties" ]&#125; 插件执行顺序插件在预设(persets)前运行。 插件的执行顺序是从左往右执行。也就是说在上面的示例中，babel在进行AST遍历的时候会先调用transform-decorators-legacy插件中定义的转换方法，然后再调用transform-class-properties中的方法。 插件传参参数是由插件名称和参数对象组成的一个数组 123456789101112&#123; "plugins": [ [ "import", &#123; "libraryName": "antd", "libraryDirectory": "es", "style": "css" &#125; ], ]&#125; 插件名称插件名称如果为 @babel/plugin-xxx，可以使用短名称@babel/xx，如果为babel-plugin-xx，可以直接使用xx。 自定义插件预设(Presets)预设就是一堆插件(Plugin)的组合，从而达到某种转译的能力，就比如react中使用到的@babel/perset-react，他就是下面几种插件的组合。 @babel/plugin-syntax-jsx @babel/plugin-transform-react-jsx @babel/plugin-transform-react-display-name 当然我们也可以手动的在plugins中配置一系列的plugin来达到目的，就像这样： 1234567&#123; "plugins": [ "@babel/plugin-syntax-jsx", "@babel/plugin-transform-react-jsx", "@babel/plugin-transform-react-display-name" ]&#125; 但是这样一方面显得不那么优雅，另一方面增加了使用者的使用难度。如果直接使用预设就清新脱俗多了~ 12345&#123; "persets": [ "@babel/preset-react" ]&#125; 预设(Presets)的执行顺序前面提到插件的执行顺序是从左往右，而预设的执行顺序恰好反其道行之，它是从右往左。 1234567&#123; "presets": [ "a", "b", "c" ]&#125; 它的执行顺序是 c、b、a，是不是有点奇怪，这主要是为了确保向后兼容，因为大多数用户将 “es2015” 放在 “stage-0” 之前。 自定义预设(Presets)那些她认识你而你不认识她的预设(Presets) @babel/preset-stage-xxx @babel/perset-stage-xxx 是ES在不同阶段语法提案的转码规则而产生的预设，随着被批准为ES新版本的组成部分而进行相应的改变（例如ES6/ES2015）。 提案分为以下几个阶段： stage-0，设想：只是一个想法，可能有babel插件，stage-0的功能范围最广，包含stage-1，stage-2，stage-3的所有功能 stage-1，建议：这是值得跟进的 stage-2，草案：初始规范 stage-3，候选：完成规范并在浏览器上初步实现 stage-4，完成：将添加到下一个年度版本发布中 @babel-preset-es2015 preset-es2015是仅包含ES6功能的Babel预设。 实际上在babel7出来后上面提到的这些预设stage-x，preset-es2015都可以废弃了，因为@bael/preset-env出来一统江湖了。 @babel/preset-env 前面两个预设是从ES标准的维度来确定转码规则的，而@babel/preset-env是根据浏览器的不同版本中缺失的功能确定转换规则的，在配置的时候我们只需要配置需要支持的浏览器版本就好了，@babel/preset-env会根据目标浏览器生成对应的插件列表然后进行编译： 12345678910&#123; "presets": [ ["env", &#123; "targets": &#123; "browser": ["last 10 versions", "ie &gt;= 9"] &#125; &#125;], ], ...&#125; 在默认情况下@babel/preset-env支持将JS目前最新的语法转成ES5，但需要注意的是，如果你代码中用到了还没有成为JS标准的语法，该语法暂时还处于stage阶段，这个时候还是需要安装对应的stage预设，不然编译会报错。 12345678910&#123; "presets": [ ["env", &#123; "targets": &#123; "browsers": ["last 10 versions", "ie &gt;= 9"] &#125; &#125;], ], "stage-0"&#125; 虽然可以采用默认配置，但如果不需要照顾所有的浏览器，还是建议你配置目标浏览器和环境，这样可以保证编译后的代码体积足够小，因为在有的版本浏览器中，新语法本身就能执行，不需要编译。@babel/preset-env 在默认情况下和 preset-stage-x 一样只编译语法，不会对新方法和新的原生对象进行转译，例如： 123const arrFun = ()=&gt;&#123;&#125;const arr = [1,2,3]console.log(arr.includes(1)) 转换后 123456"use strict";var arrFun = function arrFun() &#123;&#125;;var arr = [1, 2, 3];console.log(arr.includes(1)); 箭头函数被转换了，但是 Array.includes 方法，并没有被处理，这个时候要是程序跑在低版本的浏览器上，就会出现 includes is not function 的错误。这个时候就需要 polyfill 闪亮登场了。 Polyfillpolyfill 的翻译过来就是垫片，垫片就是垫平不同浏览器环境的差异，让大家都一样。 @babel/polyfill 模块可以模拟完整的ES5环境。 babel7.4以上版本已经弃用，可以用core-js代替注意 @babel/polyfill 不是在 Babel 配置文件中配置，而是在我们的代码中引入。 12345import '@babel/polyfill';const arrFun = ()=&gt;&#123;&#125;const arr = [1,2,3]console.log(arr.includes(1))Promise.resolve(true) 这样在低版本的浏览器中也能正常运行了。 使用core-js代替，不需要在文件中引入@babel/polyfill 123456789101112131415&#123; "presets": [ "@babel/preset-flow", [ "@babel/preset-env", &#123; "targets": &#123; "node": "8.10" &#125;, "corejs": "3", // 声明 corejs 版本 "useBuiltIns": "usage" &#125; ] ]&#125; ECMAScript 和 JavaScript 的关系ECMAScript 和 JavaScript 的关系是，前者是后者的规格，后者是前者的一种实现。]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[判断数据类型的几种方式]]></title>
    <url>%2F2020%2F02%2F28%2F2020%2F2%E6%9C%88%2F0228%2F</url>
    <content type="text"><![CDATA[判断数据类型1. typeof返回数据类型，包含这7种： number、boolean、symbol、string、object、undefined、function。 引用类型，除了function返回function类型外，其他均返回object。 其中，null 有属于自己的数据类型 Null ， 引用类型中的 数组、日期、正则 也都有属于自己的具体类型，而 typeof 对于这些类型的处理，只返回了处于其原型链最顶端的 Object 类型，没有错，但不是我们想要的结果。 2. Object.prototype.toString.call()toString() 是 Object 的原型方法，调用该方法，默认返回当前对象的 [[Class]] 。这是一个内部属性，其格式为 [object Xxx] ，其中 Xxx 就是对象的类型。 对于 Object 对象，直接调用 toString() 就能返回 [object Object] 。而对于其他对象，则需要通过 call / apply 来调用才能返回正确的类型信息。 12345678910111213Object.prototype.toString.call('') ; // [object String]Object.prototype.toString.call(1) ; // [object Number]Object.prototype.toString.call(true) ; // [object Boolean]Object.prototype.toString.call(Symbol()); //[object Symbol]Object.prototype.toString.call(undefined) ; // [object Undefined]Object.prototype.toString.call(null) ; // [object Null]Object.prototype.toString.call(new Function()) ; // [object Function]Object.prototype.toString.call(new Date()) ; // [object Date]Object.prototype.toString.call([]) ; // [object Array]Object.prototype.toString.call(new RegExp()) ; // [object RegExp]Object.prototype.toString.call(new Error()) ; // [object Error]Object.prototype.toString.call(document) ; // [object HTMLDocument]Object.prototype.toString.call(window) ; //[object global] window 是全局对象 global 的引用 3. constructorconstructor是原型prototype的一个属性，当函数被定义时候，js引擎会为函数添加原型prototype，并且这个prototype中constructor属性指向函数引用， 因此重写prototype会丢失原来的constructor。 不过这种方法有问题：1：null 和 undefined 无constructor，这种方法判断不了。 2：还有，如果自定义对象，开发者重写prototype之后，原有的constructor会丢失，因此，为了规范开发，在重写对象原型时一般都需要重新给 constructor 赋值，以保证对象实例的类型不被篡改。 4. instanceofinstanceof 是用来判断 A 是否为 B 的实例，表达式为：A instanceof B，如果 A 是 B 的实例，则返回 true,否则返回 false。 在这里需要特别注意的是：instanceof 检测的是原型， 由上图可以看出[]的原型指向Array.prototype，间接指向Object.prototype, 因此 [] instanceof Array 返回true， [] instanceof Object 也返回true。 instanceof 只能用来判断两个对象是否属于实例关系， 而不能判断一个对象实例具体属于哪种类型。]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端有哪些页面优化方法?]]></title>
    <url>%2F2020%2F02%2F27%2F2020%2F2%E6%9C%88%2F0227%2F</url>
    <content type="text"><![CDATA[前端有哪些页面优化方法? 减少http请求数 从设计实现层面简化页面，减少元素的使用 合理设置http缓存 资源合并与压缩 合并css图片，减少请求数的又一个好办法 将外部脚本置底（页面信息加载后在加载） 多图页面使用图片懒加载 在js中尽量减少闭包的使用 尽量合并css和js文件 尽量使用字体图标或者svg图标，来代替传统的png等格式图片 减少对dom的操作 尽可能使用事件委托（事件代理）来处理事件绑定的操作 移动端的兼容问题 给移动端添加点击事件会有300S的延迟 如果用点击事件，需要引一个fastclick.js文件，解决300s的延迟 一般在移动端用ontouchstart、ontouchmove、ontouchend 移动端点透问题,touchstart 早于 touchend 早于click,click的触发是有延迟的，这个时间大概在300ms左右，也就是说我们tap触发之后蒙层隐藏， 此时 click还没有触发，300ms之后由于蒙层隐藏，我们的click触发到了下面的a链接上尽量都使用touch事件来替换click事件。例如用touchend事件(推荐)。用fastclick，github.com/ftlabs/fast…用preventDefault阻止a标签的click消除 IE10 里面的那个叉号input:-ms-clear{display:none;} 设置缓存 手机页面通常在第一次加载后会进行缓存，然后每次刷新会使用缓存而不是去重新向服务器发送请求。如果不希望使用缓存可以设置no-cache。 圆角BUG 某些Android手机圆角失效 background-clip: padding-box; 防止手机中网页放大和缩小 这点是最基本的，做为手机网站开发者来说应该都知道的，就是设置meta中的viewport 设置用户截止缩放，一般写视口的时候就已经写好了。]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[call bind apply的区别？js垃圾回收]]></title>
    <url>%2F2020%2F02%2F26%2F2020%2F2%E6%9C%88%2F0226%2F</url>
    <content type="text"><![CDATA[call bind apply的区别？ call() 和 apply()的第一个参数相同，就是指定的对象。这个对象就是该函数的执行上下文。 call()和apply()的区别就在于，两者之间的参数。 call()在第一个参数之后的后续所有参数就是传入该函数的值 apply()只有两个参数，第一个是对象，第二个是数组，这个数组就是该函数的参数。bind()方法和前两者不同在于：bind()方法会返回执行上下文被改变的函数而不会立即执行，而前两者是直接执行该函数。他的参数和call()相同. js垃圾回收JavaScript中的内存管理是自动执行的，而且是不可见的。我们创建基本类型、对象、函数….所有这些都需要内存.当不再需要某样东西时会发生什么? JavaScript 引擎是如何发现并清理它? 1）问什么是垃圾 一般来说没有被引用的对象就是垃圾，就是要被清除， 有个例外如果几个对象引用形成一个环，互相引用，但根访问不到它们，这几个对象也是垃圾，也要被清除。 2）如何检垃圾 一种算法是标记 标记-清除 算法]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css问题]]></title>
    <url>%2F2020%2F02%2F25%2F2020%2F2%E6%9C%88%2F0225%2F</url>
    <content type="text"><![CDATA[css问题用纯css创建一个三角形123456789101112131415&lt;head&gt; &lt;style&gt; div &#123; width: 0; height: 0; border-top: 40px solid transparent; border-left: 40px solid transparent; border-right: 40px solid transparent; border-bottom: 40px solid #ff0000; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;&lt;/div&gt;&lt;/body&gt; 如何理解css的盒模型 标准盒子模型：宽度=内容的宽度（content）+ border + padding低版本IE盒子模型：宽度=内容宽度（content+border+padding) box-sizing属性 content-box：默认值。这是 CSS2.1 指定的宽度和高度的行为。指定元素的宽度和高度（最小/最大属性）适用于box的宽度和高度。元素的填充和边框布局和绘制指定宽度和高度除外。 border-box： 指定宽度和高度（最小/最大属性）确定元素边框。也就是说，对元素指定宽度和高度包括了 padding 和 border 。通过从已设定的宽度和高度分别减去边框和内边距才能得到内容的宽度和高度。 inherit： 指定 box-sizing 属性的值，应该从父元素继承 浏览器的兼容性问题大多数浏览器都会按照上面的图示来呈现内容。然而 IE 5 和 6 的呈现却是不正确的。根据 W3C 的规范，元素内容占据的空间是由 width 属性设置的，而内容周围的 padding 和 border 值是另外计算的。不幸的是，IE5.X 和 6 在怪异模式中使用自己的非标准模型。这些浏览器的 width 属性不是内容的宽度，而是内容、内边距和边框的宽度的总和。 如何清除浮动？ clear清除浮动（添加空div法）在浮动元素下方添加空div,并给该元素写css样式 {clear:both;height:0;overflow:hidden;} 给浮动元素父级设置高度 父级同时浮动（需要给父级同级元素添加浮动） 父级设置成inline-block，其margin: 0 auto居中方式失效 给父级添加overflow:hidden 清除浮动方法 万能清除法 after伪类 清浮动（现在主流方法，推荐使用） 1234567891011div &#123; zoom: 1; &amp;:after &#123; content: ''; clear: both; display: block; height: 0; overflow: hidden; visibility: hidden; &#125;&#125;]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[谈谈你对Redux的理解]]></title>
    <url>%2F2020%2F02%2F24%2F2020%2F2%E6%9C%88%2F0224%2F</url>
    <content type="text"><![CDATA[谈谈你对Redux的理解使用Redux应该遵循的原则： 整个应用共享的state应该存储在store的状态树中，store是唯一的 state不能直接修改，只能通过action表达修改的意图，调用dispatch()修改state state的修改规则reducers必须是一个纯函数，不能有副作用 Redux提供的API createStorecreateStore的作用就是创建一个Redux，store用来存放应用中所有的statecreateStore(reducer, [perloadState], [enhancer])createStore方法接受3个参数，后面两个是可选参数reducer: 参数的类型必须是functionperloadState: 这个参数代表初始化的state(initialState), 可以是任意类型的参数enhancer: 这个参数代表添加的各种中间件，参数的类型必须是function combineReducerscombineReducers主要是把多个reducer合并成一个，并且返回一个新的reducer函数，该函数接收的参数也是两个state和action compose主要是在中间件时候使用，合成函数compose(applyMiddleware(thunk), window.devToolsExtension ? window.devToolsExtension() : undefined) applyMiddleware bindActionCreatorbindActionCreator的主要作用就是将aciton与dispatch函数绑定，生成直接可以出发action的函数 从输入URL到页面加载的全过程123456781. 首先，在浏览器地址中输入url2. 浏览器先查看**浏览器缓存**-系统缓存-路由器缓存，如果缓存中有，会直接在屏幕中显示页面内容。若没有，则跳到第三步操作3. 浏览器向DNS（Domain Name System）服务器请求解析该URL中的域名对应的IP地址4. 解析出IP地址后，根据该IP地址和默认端口80，和服务器建立TCP连接5. 浏览器发出读取文件（URL中域名后面部分对应的文件）的HTTP请求，该请求报文作为TCP三次握手的第三个报文的数据发送给服务器6. 服务器对浏览器请求做出响应，并把对应的html文本发送给浏览器7. 释放TCP连接8. 浏览器将该html文本并显示内容 重绘（Repaint） &amp; 回流（重排Reflow） 重绘(repaint)：当我们对DOM的修改导致的样式变化，但未影响几何属性时，浏览器不需要重新计算元素的几何属性，直接可以为该元素绘制新的样式，跳过了回流环节，这个过程就叫重绘。 回流（重排 reflow）：对DOM树进行渲染，只要修改DOM或修改元素的形状大小，就会触发reflow，reflow的时候，浏览器会使已渲染好受到影响的部分失效，并重新构造这部分，完成reflow后，浏览器会重新绘制受影响的部分到屏幕中 回流必定会发生重绘，重绘不一定发生回流 12345678910// 触发Reflow增加、删除、修改DOM节点时，会导致Reflow或Repaint移动DOM的位置，或是搞个动画的时候修改CSS样式的时候（宽、高、内外边距、边框等）Resize窗口的时候（移动端没有这个问题），或是滚动的时候改变元素内容（文本或图片等）修改网页的默认字体时// 触发RepaintDOM改动CSS改动 如何减少回流、重绘？减少回流、重绘就是减少对DOM的操作 1.直接改变className，如果动态改变样式，则使用cssText（减少设置多项内联样式） 2.让要操作的元素进行“离线处理”，处理完后一起更新 当使用DocumentFragment进行缓存操作，引发一次回流和重绘 使用display:none 技术，只引发两次回流和重绘 使用cloneNode(true or false)和replaceChild技术，引发一次回流和重绘 3.不要经常访问会引起浏览器flush队列的属性，如果你确实要访问，利用缓存 4.让元素脱离动画流，减少render 树的规模 5.牺牲平滑度换取速度 6.避免使用table布局 7.IE中避免使用javascript表达式 跨域通信的几种方式 JSONP（只支持get请求） window + hash window + domain window + name postMessage WebSocket CORS（Cross-origin resource sharing）跨域资源共享（所有的HTTP请求） nginx反向代理 http-proxy服务端代理请求 前端错误类 即时运行错误：代码错误；捕获方式：try…catch…、window.onerror 资源加载错误；object.onerror（不会冒泡 ）、performance.getEntries、Error事件捕获 浅拷贝 循环遍历 123456789101112131415161718const arr1 = [1, 2, ['ming', 'abc'], 5];const shallowClone = (arr) =&gt; &#123; const dst = []; for (let prop in arr) &#123; if (arr.hasOwnProperty(prop)) &#123; dst[prop] = arr[prop]; &#125; &#125; return dst;&#125;const arr2 = shallowClone(arr1);arr2[2].push('wuhan');arr2[3] = 5;console.log(arr1); [1, 2, ['ming', 'abc', 'wuhan'], 5]console.log(arr2); [1, 2, ['ming', 'abc', 'wuhan'], 5] object.assign() Array.prototype.concat() Array.prototype.slice() obj展开运算符 深拷贝 手动递归 1234567891011121314151617181920212223242526272829303132333435363738function deepClone (sourceObj, targetObj) &#123; let cloneObj = targetObj || &#123;&#125; if(!sourceObj || typeof sourceObj !== "object" || sourceObj.length === undefined)&#123; return sourceObj &#125; if(sourceObj instanceof Array)&#123; cloneObj = sourceObj.concat() &#125; else &#123; for(let i in sourceObj)&#123; if (typeof sourceObj[i] === 'object') &#123; cloneObj[i] = deepClone(sourceObj[i], &#123;&#125;) &#125; else &#123; cloneObj[i] = sourceObj[i] &#125; &#125; &#125; return cloneObj&#125;let sourceObj = &#123; a: 1, b: &#123; a: 1 &#125;, c: &#123; a: 1, b: &#123; a: 1 &#125; &#125;, d: function() &#123; console.log('hello world') &#125;, e: [1, 2, 3]&#125;let targetObj = deepClone(sourceObj, &#123;&#125;)targetObj.c.b.a = 9console.log(sourceObj)console.log(targetObj) JSON.parse(JSON.stringify()) 1234561.如果json里面有时间对象，则序列化结果：时间对象=&gt;字符串的形式；2.如果json里有RegExp、Error对象，则序列化的结果将只得到空对象 RegExp、Error =&gt; &#123;&#125;；3.如果json里有 function,undefined，则序列化的结果会把 function,undefined 丢失；4.如果json里有NaN、Infinity和-Infinity，则序列化的结果会变成null；5.如果json里有对象是由构造函数生成的，则序列化的结果会丢弃对象的 constructor；6.如果对象中存在循环引用的情况也无法实现深拷贝 lodash函数库 123456789101112131415161718var _= require('lodash');const obj1 = [ 1, 'Hello!', &#123; name:'ming1' &#125;, [ &#123; name:'meng1', &#125; ],]const obj2 = _.cloneDeep(obj1);obj2[0] = 2;obj2[1] = 'Hi!';obj2[2].name = 'ming2'obj2[3][0].name = 'meng2';console.log(obj1);console.log(obj2);]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Symbol的应用场景]]></title>
    <url>%2F2020%2F02%2F20%2F2020%2F2%E6%9C%88%2F0220%2F</url>
    <content type="text"><![CDATA[Symbol的应用场景应用场景1：使用Symbol来作为对象属性名（key）12345678910111213let obj = &#123; [Symbol()]: 'test', a: 1, b: 2,&#125;;Object.keys(obj); // ['a', 'b']for (let p in obj) &#123; console.log(p); // 分别输出: a 和 b&#125;Object.getOwnPropertyNames(obj); // ['a', 'b'] 由上代码可知，Symbol类型的key是不能通过Object.keys()或者for…in来枚举的，它未被包含对象自身的属性名集合（property names）之中。所以，利用该特性，我们可以把一些不需要对外操作和访问的属性使用Symbol来定义。 应用场景2：使用Symbol来替代常量12345678910111213141516171819const TYPE_AUDIO = 'AUDIO'const TYPE_VIDEO = 'VIDEO'const TYPE_IMAGE = 'IMAGE'function handleFileResource(resource) &#123; switch(resource.type) &#123; case TYPE_AUDIO: playAudio(resource) break case TYPE_VIDEO: playVideo(resource) break case TYPE_IMAGE: previewImage(resource) break default: throw new Error('Unknown type of resource') &#125;&#125; 如上面的代码中那样，我们经常定义一组常量来代表一种业务逻辑下的几个不同类型，我们通常希望这几个常量之间是唯一的关系，常量少的时候还算好，但是常量一多，你可能还得花点脑子好好为他们取个好点的名字。 现在有了Symbol，我们大可不必这么麻烦了： 123const TYPE_AUDIO = Symbol()const TYPE_VIDEO = Symbol()const TYPE_IMAGE = Symbol() 应用场景3：使用Symbol定义类的私有属性/方法使用的少 彻底搞懂浏览器Event-loop1. 预备知识1JavaScript的运行机制 (1) 所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。(2) 主线程之外，还存在”任务队列”（task queue）。只要异步任务有了运行结果，就在”任务队列”之中放置一个事件。(3) 一旦”执行栈”中的所有同步任务执行完毕，系统就会读取”任务队列”，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。(4) 主线程不断重复上面的第三步 概况就是：调用栈中的同步任务都执行完毕，栈内被清空了，就代表主线程空闲了，这个时候就会去任务队列中按照顺序读取一个任务放入到栈中执行。每次栈内被清空，都会去读取任务队列有没有任务，有就读取执行，一直循环读取-执行的操作。 1JavaScript中有两种异步任务： 宏任务：script（整体代码），setTimeout、setInterval、setImmediate、I/O、UI rendering 微任务：process.nextTick（Nodejs）、Promise、Object.observe、MutationObServer 2. 事件循环（event-loop）是什么？主线程从”任务队列”中读取执行事件，这个过程是循环不断的，这个机制被称为事件循环。此机制具体如下：主线程会不断从任务队列中按顺序读取任务执行，每执行一个任务都会检查microtask队列是否为空（执行完一个任务的具体标志是函数执行栈为空），如果不为空则会一次性执行完所有microtask。然后进入下一个循环去任务队列中取下一个任务执行。 当前执行栈执行完毕时会立刻先处理所有微任务队列中的事件, 然后再去宏任务队列中取出一个事件。同一次事件循环中, 微任务永远在宏任务之前执行。 3. 为什么会需要event-loop?因为 JavaScript 是单线程的。单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着。为了协调事件（event），用户交互（user interaction），脚本（script），渲染（rendering），网络（networking）等，用户代理（user agent）必须使用事件循环（event loops）。 node中的event-loop与浏览器之间的差异浏览器和 Node 环境下，microtask 任务队列的执行时机不同 Node 端，microtask 在事件循环的各个阶段之间执行 浏览器端，microtask 在事件循环的 macrotask 执行完之后执行 123456789101112131415161718192021console.log('start')setTimeout(() =&gt; &#123; console.log('timer1') Promise.resolve().then(function() &#123; console.log('promise1') &#125;)&#125;, 0)setTimeout(() =&gt; &#123; console.log('timer2') Promise.resolve().then(function() &#123; console.log('promise2') &#125;)&#125;, 0)Promise.resolve().then(function() &#123; console.log('promise3')&#125;)console.log('end')// 浏览器 start=&gt;end=&gt;promise3=&gt;timer1=&gt;promise1=&gt;timer2=&gt;promise2// node start=&gt;end=&gt;promise3=&gt;timer1=&gt;timer2=&gt;promise1=&gt;promise2]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iframe的优缺点]]></title>
    <url>%2F2019%2F10%2F09%2F2019%2F%E6%B5%85%E8%B0%88iframe%2F</url>
    <content type="text"><![CDATA[iframe的优缺点iframe的优点： iframe能够原封不动的把嵌入的网页展现出来。 如果有多个网页引用iframe，那么你只需要修改iframe的内容，就可以实现调用的每一个页面内容的更改，方便快捷。 网页如果为了统一风格，头部和版本都是一样的，就可以写成一个页面，用iframe来嵌套，可以增加代码的可重用。 如果遇到加载缓慢的第三方内容如图标和广告，这些问题可以由iframe来解决。 iframe的缺点： 会产生很多页面，不容易管理。 iframe框架结构有时会让人感到迷惑，如果框架个数多的话，可能会出现上下、左右滚动条，会分散访问者的注意力，用户体验度差。 代码复杂，无法被一些搜索引擎索引到，这一点很关键，现在的搜索引擎爬虫还不能很好的处理iframe中的内容，所以使用iframe会不利于搜索引擎优化。 很多的移动设备（PDA 手机）无法完全显示框架，设备兼容性差。 iframe框架页面会增加服务器的http请求，对于大型网站不是可取的。 iframe迁移问题以及解决方案 import React, { propTypes } from ‘react’; error: PropTypes is undefined; 出现原因: React在新版本中废弃了集成类似propTypes这种第三方库方案。 解决方案: 新仓库使用的react版本较高，以上方式已被废弃，应使用 1import PropTypes from 'prop-types'; import ‘./style.less’; error: 样式失效问题。 出现原因: 新项目中开启了css-module，需要通过配置:global来声明一个全局class，使其在全局起作用。 解决方案1: 1234567### style.less.content &#123; :global &#123; .items &#123;&#125; &#125;&#125; 12345import styles from './style.less';&lt;div className=&#123;styles.content&#125;&gt; &lt;div className="items"&gt;&lt;/div&gt;&lt;/div&gt; 解决方案2: 1234567# style.less:global &#123; .content &#123; .items &#123;&#125; &#125;&#125; 1234import './style.less';&lt;div className="content"&gt; &lt;div className="items"&gt;&lt;/div&gt;&lt;/div&gt; 推荐使用方案1，可以利用css-module的命名规则减少项目中样式的冲突问题。方案2改动小但是太暴力，非常可能产生样式冲突问题。 comm和components中组件出现不可用情况。 error: 功能不可用情况。 解决方案: 建议直接使用antd替换，需要花上一点时间对应antd api做一定代码重构。(!这块需要仔细效验功能是否正常) ec_fe中使用了Component.contextTypes。 例如： 1234Manage.contextTypes = &#123; history: PropTypes.object.isRequired, store: PropTypes.object.isRequired&#125;; Warning: Failed context type: The context history is marked as required in Connect(ContractReview), but its value is undefined. 解决方案：拆分出去的仓库，react-router版本使用的是4.x，已经不需要像老版本一样一层层传递history或者绑定在Context上共享的方式。 ec_fe中使用了this.props.router等路由api 123456this.props.router.replace(&#123; pathname: `/admin/web/packageconfig/function.html`, query: &#123; id: moduleList[0].f_id, &#125;,&#125;); 错误：index.jsx:59 Uncaught TypeError: Cannot read property ‘replace’ of undefined 解决方案：拆分出去的仓库，react-router版本使用的是4.x，请使用react-router-dom提供的api修改。 1234this.props.history.replace(&#123; pathname: `/packageconfig/funModule`, search: `id=$&#123;moduleList[0].f_id&#125;`,&#125;); 参考资料 浅谈iframe react-router-dom]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NextTick 原理分析]]></title>
    <url>%2F2019%2F06%2F13%2F2019%2FJune%2FNextTick%2FREADME%2F</url>
    <content type="text"><![CDATA[NextTick 原理分析nextTick可以让我们在下次DOM更新循环结束之后执行延迟回调，用于获得更新后的DOM。 在Vue2.4之前都是使用的microtasks，但是microtasks的优先级过高，在某些情况下可能会出现比事件冒泡更快的情况，但如果都是macrotasks又可能会出现渲染的性能问题。所以在新版本中，会默认使用microtasks，但在特殊情况下会使用macrotasks，比如v-on。 对于实现macrotasks，会先判断是否能使用setImmediate，不能的话降级为MessageChannel，以上都不行的话就使用setTimeout。 123456789101112131415161718192021if (typeof setImmediate !== 'undefined' &amp;&amp; isNative(setImmediate)) &#123; macroTimerFunc = () =&gt; &#123; setImmediate(flushCallbacks) &#125;&#125; else if ( typeof MessageChannel !== 'undefined' &amp;&amp; (isNative(MessageChannel) || // PhantomJS MessageChannel.toString() === '[object MessageChannelConstructor]')) &#123; const channel = new MessageChannel() const port = channel.port2 channel.port1.onmessage = flushCallbacks macroTimerFunc = () =&gt; &#123; port.postMessage(1) &#125;&#125; else &#123; macroTimerFunc = () =&gt; &#123; setTimeout(flushCallbacks, 0) &#125;&#125; 以上代码用来判断能不能使用相应的API。 注解 macrotasks（宏任务）： setTimeout, setInterval, setImmediate, I/O, UI rendering microtasks（微任务）： process.nextTick, Promise, MutationObserver]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git的基本操作]]></title>
    <url>%2F2019%2F06%2F09%2F2019%2FJune%2Fgit%2FREADME%2F</url>
    <content type="text"><![CDATA[git Rebase 合并 stash reflog Reset Rebase 合并该命令可以让和 merge 命令得到的结果基本是一致的。 通常使用 merge 操作将分支上的代码合并到 master 中，分支样子如下所示 使用 rebase 后，会将 develop 上的 commit 按顺序移到 master 的第三个 commit 后面，分支样子如下所示 Rebase 对比 merge，优势在于合并后的结果很清晰，只有一条线，劣势在于如果一旦出现冲突，解决冲突很麻烦，可能要解决多个冲突，但是 merge 出现冲突只需要解决一次。 使用 rebase 应该在需要被 rebase 的分支上操作，并且该分支是本地分支。如果 develop 分支需要 rebase 到 master 上去，那么应该如下操作 12345## branch developgit rebase masterget checkout master## 用于将 `master` 上的 HEAD 移动到最新的 commitget merge develop stashstash 用于临时报错工作目录的改动。开发中可能会遇到代码写一半需要切分支打包的问题，如果这时候你不想 commit 的话，就可以使用该命令。 1git stash 使用该命令可以暂存你的工作目录，后面想恢复工作目录，只需要使用 1git stash pop 这样你之前临时保存的代码又回来了 reflogreflog 可以看到 HEAD 的移动记录，假如之前误删了一个分支，可以通过 git reflog 看到移动 HEAD 的哈希值 从图中可以看出，HEAD 的最后一次移动行为是 merge 后，接下来分支 new 就被删除了，那么我们可以通过以下命令找回 new 分支 12git checkout 37d9acagit checkout -b new PS：reflog 记录是时效的，只会保存一段时间内的记录。 Reset如果你想删除刚写的 commit，就可以通过以下命令实现 1git reset --hard HEAD^ 但是 reset 的本质并不是删除了 commit，而是重新设置了 HEAD 和它指向的 branch。 git 常用操作$ git ch(checkout) -b develop 创建开发分支develop $ git push 推送当前分支到远端仓库 $ git st(status) 查看当前分支工作区、暂存区的工作状态 $ git diff diff文件的修改 $ git ci(commit) . 提交本次修改 $ git fetch –all 拉取所有远端的最新代码 $ git merge origin/develop 如果是多人协作，merge同事的修改到当前分支（先人后己原则） $ git merge origin/master 上线之前保证当前分支不落后于远端origin/master，一定要merge远端origin/master到当前分支 $ git push 推送当前分支到远端仓库 $ git merge –no-ff origin/develop 同事review code之后管理员合并origin/develop到远端主干origin/master 👉 HEAD：当前commit引用$ git version git版本 $ git branch 查看本地所有的分支 $ git branch -r 查看所有远程的分支 $ git branch -a 查看所有远程分支和本地分支 $ git branch -d 删除本地branchname分支 $ git branch -m brancholdname branchnewname 重命名分支 $ git branch 创建branchname分支 $ git checkout 切换分支到branchname $ git checkout -b 等同于执行上两步，即创建新的分支并切换到该分支 $ git checkout – xx/xx 撤销本文件的更改 $ git pull origin master:master 将远程origin主机的master分支合并到当前master分支,冒号后面的部分表示当前本地所在的分支 $ git pull origin master –allow-unrelated-histories 允许合并两个不同项目的历史记录 $ git push origin -d 删除远程branchname分支 $ git fetch –p 更新分支 $ git status 查看本地工作区、暂存区文件的修改状态 $ git add xx 把xx文件添加到暂存区去 $ git commit -m ‘ ‘ 提交文件 -m 后面的是注释 $ git commit -am(-a -m) 提交所有的修改，等同于上两步 $ git commit ./xx 等同于git add ./xx + git commit]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从零配置webpack（基于webpack 4 和 babel 7版本）]]></title>
    <url>%2F2019%2F05%2F25%2F2019%2FMay%2FWebpack%2FREADME%2F</url>
    <content type="text"><![CDATA[从零配置webpack（基于webpack 4 和 babel 7版本）webpack 核心概念 Entry: 入口 Module: 模块，webpack中一切皆是模块 Chunk: 代码库，一个chunk由十多个模块组合而成，用于代码合并与分割 Loader: 模块转换器，用于把模块原内容按照需求转换成新内容 Plugin: 扩展插件，在webpack构建流程中的特定时机注入扩展逻辑来改变构建结果或做你想要的事情 Output: 输出结果 webpack 流程webpack启动后会从Entry里配置的Module开始递归解析Entry依赖的所有Module。每找到一个Module，就会根据配置的Loader去找出对应的转换规则，对Module进行转换后，再解析出当前的Module依赖的Module。这些模块会以Entry为单位进行分组，一个Entry和其所有依赖的Module被分到一个组也就是一个Chunk。最好Webpack会把所有Chunk转换成文件输出。在整个流程中Webpack会在恰当的时机执行Plugin里定义的逻辑。 最简webpack配置首先初始化npm和安装webpack的依赖： 12npm init -yyarn add webpack webpack-cli --dev 配置webpack.config.js文件： 12345678910const path = require('path');module.export = &#123; entry: path.resolve(__dirname, 'src/index.js'), output: &#123; path: path.resolve(__dirname, 'dist'), filename: 'bundle.js', // 此处不设置，默认为 main.js publicPath: '/' &#125;&#125; 说明: publicPath上线时配置的是cdn的地址。 使用命令进行打包： 1webpack --mode production 也可以将其配置到package.json中的 scripts 字段。入口文件为src/index.js，打包输出到dist/bundle.js。 使用模板htmlhtml-webpack-plugin 可以指定 template 模板文件，将会在 output 目录下，生成 html 文件，并引入打包后的js。安装依赖： 1yarn add html-webpack-plugin --dev 在 webpack.config.js 增加 plugins 配置： 12345678910const HtmlWebpackPlugin = require('html-webpack-plugin');module.exports = &#123; // ... other code plugins: [ new HtmlWebpackPlugin(&#123; template: path.resolve(__dirname, 'src/index.html') &#125;) ]&#125; HtmlWebpackPlugin 还有一些其他的参数，如title（html的title），minify（是否要压缩），filename（dist中生成的html文件名）等。 配置 webpack-dev-serverwebpack-dev-server 提供了一个简单的Web服务器和实时热更新的能力。安装依赖： 1yarn add webpack-dev-server --dev 在 webpck.config.js 增加 devServer 配置： 12345678910const WebpackDevServer = require('webpack-dev-server');module.exports = &#123; // ... other code devServer: &#123; contentBase: './dist', port: '8080', host: 'localhost' &#125;&#125; 在 package.json 的 scripts 字段中增加： 1dev: 'webpack-dev-server --mode development' 之后，我们就可以通过 npm run dev，来启动服务。更多关于 webpack-dev-server 支持加载 css 文件通过使用不同的 style-loader 和 css-loader，可以将 css 文件转换成js文件类型。安装依赖： 1yarn add style-loader css-loader --dev 在 webpack.config.js 中增加 loader 的配置。 12345678910111213module.exports = &#123; // ...other code module: &#123; rules: [ &#123; test: /\.css/, use: ['style-loader', 'css-loader'], exclude: /node_module/, include: path.resolve(__dirname, 'src') &#125; ] &#125;&#125; loader 可以配置以下参数： test: 匹配处理文件的扩展名的正则表达式 use: loader的名称 include/exclude: 手动指定必须处理的文件夹或屏蔽不需要处理的文件夹 query: 为loader提供额外的设置选项 如果需要给loader传参，那么可以使用use + loading的方式，如： 12345678910111213141516171819module.exports = &#123; // other code module: &#123; rules: [ &#123; use: [ &#123; loader: 'style-loader', options: &#123; insertAt: 'top' &#125; &#125;, 'css-loader' ], // ... &#125; ] &#125;&#125; 支持加载图片 file-loader: 解决css等文件中的引入图片路径问题 url-loader: 当图片小于limit的时候会把图片base64编码，大于limit参数的时候还是使用file-loader进行拷贝 如果希望图片存放在单独的目录下，那么需要制定outputPath 安装依赖： 1yarn add url-loader file-loader --dev 在 webpack.config.js 中增加loader的配置（增加在 module.rules的数组中）。 12345678910111213141516171819module.exports = &#123; // ...other code module: &#123; rules: [ &#123; test: /\.(gif|jpg|png|bmp|eot|woff|woff2|ttf|svg)/, use: [ &#123; loader: 'url-loader', options: &#123; limit: 8192, outputPath: 'images' &#125; &#125; ] &#125; ] &#125;&#125; 支持编译less和sass现在大家都习惯使用less或者sass编写css，那么也需要在webpack中进行配置。安装对应的依赖： 12yarn add less less-loader --devyarn add sass sass-loader --dev 在 webpack.config.js 中增加 loader 的配置（module.rules数组中）。 12345678910111213141516171819module.exports = &#123; // .. other code module: &#123; rules: [ &#123; test: /\.less/, use: ['style-loader', 'css-loader', 'less-loader'], exclude: /node_modules/, include: path.resolve(__dirname, 'src') &#125;, &#123; test: /\.scss/, use: ['style-loader', 'css-loader', 'sass-loader'], exclude: /nodu_modules/, include: path.resolve(__dirname, 'src') &#125; ] &#125;&#125; 支持转义 ES6/ES7/JSXES6/ES7/JSX 转义需要 Babel 的依赖，支持装饰器 1yarn add @babel/core babel-loader @babel/preset-env @babel/preset-react @babel/plugin-proposal-decorators @babel/plugin-proposal-object-rest-spread --dev 在 webpack.config.js 中增加 loader 的配置（module.rules 数组中）。 123456789101112131415161718192021module.exports = &#123; // ...other code module: &#123; rules: [ test: /\.jsx?$/, use: [ &#123; loader: 'babel-loader', options: &#123; presets: ['@babel/react'], plugins: [ ['@babel/plugin-proposal-decorators', &#123;'legacy': true&#125;] ] &#125; &#125; ], exclude: /nodu_modules/, include: path.resolve(__dirname, 'src') ] &#125;&#125; 压缩js文件安装依赖： 1yarn add uglifyjs-webpack-plugin --dev 在 webpack.config.js 中增加 optimization 的配置 123456789101112const UglifyWebpackplugin = require('uglifyjs-webpack-plugin');module.exports = &#123; // ... other code optimization: &#123; minimizer: [ new UglifyWebpackPlugin(&#123; parallel: 4 &#125;) ] &#125;&#125; 以上最新版webpack已经默认开启uglifyjs，不需要单独安装plugins但是它是单线程压缩的，我们还可以利用webpack-parallel-uglify-plugin，解决多个js打包并行压缩的需要，优化打包效率 1yarn add webpack-parallel-uglify-plugin --dev 在 webpack.config.js 中增加： 12345678910111213141516171819const WebpackParallelUglifyPlugin = require('webpack-parallel-uglify-plugin');module.exports = &#123; // other code plugins: [ new WebpackParallelUglifyPlugin(&#123; ugfilyJS: &#123; output: &#123; beautify: false, // 是否保留空格和制表符 comments: false, // 是否保留注释 &#125;, compress: &#123; warnings: false, // 删除没有用到的代码时的警告信息, drop_console: true, // 是否删除代码中的console语句 &#125; &#125; &#125;) ]&#125; 分离css（如果css文件较大的话）因为CSS的下载和JS可以并行，当一个html文件很大的时候，可以把css单独提取出来加载 1yarn add mini-css-extract-plugin --dev 在 webpack.config.js 中增加 plugins 的配置，并且将 ‘style-loader’ 修改为 { loader: MiniCssExtractPlugin.loader}。css打包在单独的目录，那么配置filename。 12345678910111213141516171819202122232425262728293031323334353637383940414243const MiniCssExtractPlugin = require('mini-css-extract-plugin');module.exports = &#123; module: &#123; rules: [ &#123; test: /\.css/, use: [ &#123; loader: MiniCssExtractPlugin.loader, &#125;, 'css-loader' ], exclude: /node_modules/, include: path.resolve(__dirname, 'src') &#125;, &#123; test: /\.less/, use: [ &#123; loader: MiniCssExtractPlugin.loader, &#125;, 'css-loader', 'less-loader' ], exclude: /node_modules/, include: path.resolve(__dirname, 'src') &#125;, &#123; test: /\.sass/, use: [ &#123; loader: MiniCssExtractPlugin.loader &#125;, 'css-loader', 'sass-loader' ], exclude: /node_modules/, include: path.resolve(__dirname, 'src') &#125; ] &#125;, plugins: [ new MiniCssExtractPlugin(&#123; filename: 'css/[name].css' &#125;) ]&#125; 压缩css文件安装依赖： 1yarn add optimiza-css-assets-webpack-plugin --dev 在 webpack.config.js 中的 optimization 中增加配置 12345678910const OptimizaCssAssetsWebpackPlugin = require('optimiza-css-assets-webpack-plugin');module.exports = &#123; // ... other code optimization: &#123; minimizer: [ new OptimizaCssAssetsWebpackPlugin() ] &#125;&#125; 打包前先清空输出目录1yarn add clean-webpack-plugin --dev 在 webpack.config.js 中增加 plugins 的配置 12345678const CleanWebpackPlugin = require('clean-webpack-plugin');module.exports = &#123; // ...other code plugins: [ new CleanWebpackPlugin() ]&#125;]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[This]]></title>
    <url>%2F2019%2F05%2F17%2F2019%2FMay%2FThis%2FREADME%2F</url>
    <content type="text"><![CDATA[this 默认绑定 隐式绑定 硬绑定 new绑定 默认绑定默认绑定，在不能应用其他绑定规则时使用的默认规则，通常是独立函数调用。 12345function sayHi() &#123; console.log('Hello', this.name);&#125;var name = 'achen';sayHi(); 在调用sayHi()时，应用了默认绑定，this指向全局对象（非严格模式下），严格模式下，this指向undefined，undefined上没有this对象，会抛出错误。上面的代码，如果在浏览器环境中运行，那么结果是 Hello, achen但是如果在node环境中运行，结果就是Hello, undefined，这是因为node中name并不是挂在全局对象上的。 隐式绑定函数的调用是在某个对象上触发的，即调用位置上存在上下文对象。典型的形式为 XXX.fun()。 123456789function sayHi() &#123; console.log('Hello', this.name);&#125;var person = &#123; name: 'achen', sayHi: sayHi&#125;;var name = 'achenjs';persin.sayHi(); 硬绑定（显示绑定）通过call，apply，bind的方式，显示的指定this所指向的对象。call，apply，bind的第一个参数，就是对应函数的this所指向的对象。call和apply的作用一样，只是传参方式不同。call和apply都会执行对应的函数，而bind方法不会。 12345678910function sayHi() &#123; console.log('Hello', this.name);&#125;var person = &#123; name: 'YvetteLau', sayHi: sayHi&#125;var name = 'Wiliam';var Hi = person.sayHi;Hi.call(person); // Hi.apply(person) new绑定 使用new来调用函数，会自动执行下面的操作： 创建一个新对象 将构造函数的作用域赋值给新对象，即this指向这个新对象 执行构造函数中的代码 返回新对象 12345function SayHi(name) &#123; this.name = name;&#125;var Hi = new SayHi('achen');console.log(Hi.name); // achen 输出结果为achen，原因是因为在var Hi = new SayHi(‘achen’); 这一步，会将SayHi中的this绑定到Hi对象上。 绑定优先级new绑定 &gt; 显示绑定 &gt; 隐式绑定 &gt; 默认绑定 绑定另外如果我们将null或者undefined作为this的绑定对象传入call、apply或者是bind，这些值在调用时会被忽略，实际应用的是默认绑定规则。 12345678var foo = &#123; name: 'Selina',&#125;var name = 'Chirs';function bar() &#123; console.log(this.name);&#125;bar.call(null); // Chirs 箭头函数箭头函数是ES6中新增的，它和普通函数有一些区别，箭头函数没有自己的this，它的this继承于外层代码库中的this。箭头函数在使用中，需要注意以下几点： 函数体内的this对象，继承的是外层代码块的this。 不可以当做构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。 不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用rest参数代替。 不可以使用yield命令，因此箭头函数不能用作Generator函数。 箭头函数没有自己的this，所以不能用call、apply、bind这些方法改变this的指向。 12345678910111213141516171819202122232425var obj = &#123; hi: function() &#123; console.log(this); return () =&gt; &#123; console.log(this); &#125; &#125;, sayHi: function() &#123; return function() &#123; console.log(this); return () =&gt; &#123; console.log(this); &#125; &#125; &#125;, say: () =&gt; &#123; console.log(this); &#125;&#125;;let hi = obj.hi(); // objhi(); // objlet sayHi = obj.sayHi();let fun1 = sayHi(); // windowfun1(); // windowobj.say(); // window]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实现一个promise]]></title>
    <url>%2F2019%2F05%2F15%2F2019%2FMay%2FPromise%2FmyPromise%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071const PENDING = 'PENDING';const RESOLVED = 'RESOLVED';const REJECTED = 'REJECTED';function MyPromise(fn) &#123; const that = this; that.value = null; that.state = PENDING; that.resolvedCallbacks = []; that.rejectedCallbacks = []; function resolve(value) &#123; if (value instanceof MyPromise) &#123; return value.then(resolve, reject); &#125; if (that.state === PENDING) &#123; that.state = RESOLVED; that.value = value; that.resolvedCallbacks.map(cb =&gt; cb(that.value)); &#125; &#125; function reject() &#123; if (that.state === PENDING) &#123; that.state = REJECTED; that.value = value; that.rejectedCallbacks.map(cb =&gt; cb(that.value)); &#125; &#125; try &#123; fn(resolve, reject); &#125; catch(e) &#123; reject(e); &#125;&#125;MyPromise.prototype.then = function(onFulfilled, onRejected) &#123; const that = this; onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : v =&gt; v; onRejected = typeof onRejected === 'function' ? onRejected : r =&gt; &#123; throw r &#125;; if (that.state === PENDING) &#123; that.resolvedCallbacks.push(onFulfilled); that.rejectedCallbacks.push(onRejected); &#125; if (that.state === RESOLVED) &#123; onFulfilled(that.value); &#125; if (that.state === REJECTED) &#123; onRejected(that.value); &#125; return that;&#125;new MyPromise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(111); &#125;, 0);&#125;).then(value =&gt; &#123; console.log(value); console.log(resolve);&#125;).then(value =&gt; &#123; console.log(value);&#125;)]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何写一个jQuery插件]]></title>
    <url>%2F2019%2F05%2F13%2F2019%2FMay%2FJqPlugin%2FREADME%2F</url>
    <content type="text"><![CDATA[如何写一个jQuery插件jQuery 插件开发模式jQuery的插件开发模式主要有三种： 通过$.extend()来扩展jQuery 通过$.fn向jQuery添加新的方法 通过$.widget()应用jQuery UI的部件工厂方式创建 $.extend()1234567891011121314$.fn.extend(&#123; check: function() &#123; return this.each(function() &#123; this.checked = true; &#125;), &#125; uncheck: function() &#123; return this.each(function() &#123; this.checked = false; &#125;) &#125;&#125;)$("input[type='checkbox']").check(); $.fn12345678910function myPlugin($ele, options) &#123;&#125;;myPlugin.prototype = &#123; method1: function() &#123;&#125;, method2: function() &#123;&#125;,&#125;;$.fn.myplugin = function(options) &#123; new myPlugin(this, options);&#125;]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS继承的实现方式]]></title>
    <url>%2F2019%2F05%2F11%2F2019%2FMay%2FExtends%2FREADME%2F</url>
    <content type="text"><![CDATA[JS继承的实现方式1234567891011class Animal &#123; this.name = 'Animal'; this.sleep = function() &#123; console.log(this.name + '~~~'); &#125;&#125;Animal.prototype.eat = function(food) &#123; console.log(this.name + ' eat: ' + food);&#125; 1. 原型链继承核心： 将父类的实例作为子类的原型 12345678910function Cat() &#123;&#125;Cat.prototype = new Animal();Cat.prototype.name = 'cat';var cat = new cat();console.log(cat.name); // catconsole.log(cat.eat('fish')); // cat eat: fishconsole.log(cat.sleep()); // cat~~~console.log(cat instanceof Animal); // trueconsole.log(cat instanceof Cat); // true 特点： 非常纯粹的继承关系，实例是子类的实例，也是父类的实例 父类新增原型方法/原型属性，子类都能访问到 简单，易于实现 缺点： 要想为子类新增属性和方法，必须要在new Animal()这样的语句之后执行，不能放到构造器中 无法实现多继承 来自原型对象的所有属性被所有实例共享 创建子类实例时，无法向父类构造函数传参 2. 构造继承核心：使用父类的构造函数来增强子类实例，等于是复制父类的实例属性给子类（没用到原型） 12345678910function Cat() &#123; Animal.apply(this); // Animal.call(this); this.name = 'cat';&#125;var cat = new Cat();console.log(cat.name); // catconsole.log(cat.sleep()); // cat~~~console.log(cat instanceof Animal); // falseconsole.log(cat instanceof Cat); // true 特点： 解决了1中，子类实例共享父类引用属性的问题 创建子类实例时，可以向父类传递参数 可以实现多继承（call多个父类对象） 缺点： 实例并不是父类的实例，只是子类的实例 只能继承父类的实例属性和方法，不能继承原型属性/方法 无法实现函数复用，每个子类都有父类实例函数的副本，影响性能 3. 实例继承核心：为父类实例添加新特性，做为子类实例返回 1234567891011function Cat(name) &#123; var instance = new Animal(); instance.name = name || 'Tom'; return instance;&#125;var cat = new Cat();console.log(cat.name); // Tomconsole.log(cat.sleep()); // Tom~~~console.log(cat instanceof Animal); // trueconsole.log(cat instanceof Cat); // false 特点： 不限制调用方式，不管事new 子类（）还是子类（），返回的对象具有相同的效果 缺点： 实例是父类的实例，不是子类的实例 不支持多继承 4. 拷贝继承1234567891011121314function Cat() &#123; var animal = new Animal(); for (var i in animal) &#123; Cat.prototype[i] = animal[i]; &#125; Cat.prototype.name = name || 'Tom';&#125;var cat = new Cat();console.log(cat.name); // Tomconsole.log(cat.sleep()); // Tom~~~console.log(cat instanceof Animal); // falseconsole.log(cat instanceof Cat); // true 特点： 支持多继承 缺点： 效率较低，内存占用高（因为要拷贝父类的属性） 无法获取父类不可枚举的方法（不可枚举方法，不能使用for in 访问到） 5. 组合继承核心：通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用 123456789101112function Cat(name) &#123; Animal.call(this); this.name = name || 'Tom';&#125;Cat.prototype = new Animal();Cat.prototype.constructor = Cat; // 修复Cat的构造函数var cat = new Cat();console.log(cat.name); // Tomconsole.log(cat.sleep()); // Tom~~~console.log(cat instanceof Animal); // trueconsole.log(cat instanceof Cat); // true 特点： 弥补了方式2的缺陷，可以继承实例属性/方法，也可以继承原型属性/方法 既是子类的实例，也是父类的实例 不存在引用属性共享问题 可传参 函数可复用 缺点： 调用了两次父类构造函数，生成了两份实例（子类实例将子类原型上的那份屏蔽了） 6. 寄生组合继承核心：通过寄生方式，砍掉父类的实例属性，这样，在调用两次父类的构造的时候，就不会初始化两次实例方法/属性，避免的组合继承的缺点 12345678910111213141516171819function Cat(name) &#123; Animal.call(this); this.name = name || 'Tom';&#125;(function() &#123; // 创建一个没有实例方法的类 var Super = function() &#123;&#125;; Super.prototype = Animal.prototype; // 将实例作为子类的原型 Cat.prototype = new Super(); Cat.prototype.constructor = Cat; // 修复Cat的构造函数&#125;)();var cat = new Cat();console.log(cat.name); // Tomconsole.log(cat.sleep()); // Tom~~~console.log(cat instanceof Animal); // trueconsole.log(cat instanceof Cat); //true 特点： 堪称完美 缺点： 实现较为复杂]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[修饰器的使用]]></title>
    <url>%2F2019%2F05%2F09%2F2019%2FMay%2FDecorator%2FREADME%2F</url>
    <content type="text"><![CDATA[由于使用了decorator, node不用正常识别，需要使用babel转换 1$ babel-node test.js 1. 类修饰器（只有一个参数）target: 指向类，如果是类型是function，则指向MyFunction.prototype 123456function testable(target) &#123; target.isTestable = false;&#125;@testabelclass MyTestableClass &#123;&#125; 以上代码，@testable就是一个装饰器，它为MyTestableClass这个类添加了一个静态属性isTestable 123456789function testable(isTestable) &#123; return function(target) &#123; target.isTestable = isTestable; target.prototype.name = 'achen'; &#125;&#125;@testabel(false)class MyTestabelClass &#123;&#125; 以上代码，告诉我们@testable何如传递参数，并且如何为类添加原型属性或者方法。 2. 方法修饰器（有三个参数）target: 方法所在的类name: 方法名称descriptor: 描述对象12345678910111213141516171819202122class Math &#123; @log add(a, b) &#123; return a + b; &#125;&#125;function log(target, name, descriptor) &#123; var oldValue = descriptor.value; descriptor.value = function() &#123; console.log(`Calling $&#123;name&#125; with`, arguments); return oldValue.apply(this, arguments); &#125; return descriptor;&#125;const math = new Math();math.add(2, 4); 为什么修饰器不能用于函数？修饰器只能用于类和类的方法，不能用于函数，因为存在函数提升123456789var conuter = 0;var add = function() &#123; counter++;&#125;;@addfunction foo() &#123;&#125;]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[什么是函数柯里化？]]></title>
    <url>%2F2019%2F05%2F07%2F2019%2FMay%2FCurry%2FREADME%2F</url>
    <content type="text"><![CDATA[什么是函数柯里化？实现 sum(1)(2)(3) 返回结果是1,2,3之和函数柯里化：把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数 1234567function sum(a) &#123; return function(b) &#123; return function(c) &#123; return a+b+c; &#125; &#125;&#125; 引申：实现一个curry函数，将普通函数进行柯里化123456789101112131415161718function curry(fn, args = []) &#123; return function() &#123; let rest = [...args, ...arguments]; if (rest.length &lt; fn.length) &#123; return curry.call(this, fn, rest); &#125; else &#123; return fn.apply(this, rest); &#125; &#125;&#125;//testfunction sum(a,b,c) &#123; return a+b+c;&#125;let sumFn = curry(sum);console.log(sumFn(1)(2)(3)); //6console.log(sumFn(1)(2, 3)); //6]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常见的浏览器兼容问题]]></title>
    <url>%2F2019%2F05%2F05%2F2019%2FMay%2FCompatible%2FREADME%2F</url>
    <content type="text"><![CDATA[常见的浏览器兼容问题html中的兼容问题不同浏览器的标签默认的外补丁和内补丁不同 场景：随便写几个标签，不加样式控制的情况下，各自的margin和padding差异较大。 解决方法：上来先消除默认样式* {margin: 0, padding: 0} 块属性标签float后，又有横行的margin的情况下，在IE6显示margin比设置的大（即双倍边距bug） 场景：常见症状是IE6后面的一块被顶到下一行; 解决方法：在float的标签样式控制中加入display: inline-block; 将其转化为行内属性 IE6 中z-index失效 场景：元素的父级元素设置的z-index为1，那么其子级元素再设置z-index时会失效，其层级会继承父级元素的设置，造成某些层级调整上的bug 原因：z-index起作用有个前提，就是元素的position属性要是relative、absolute或者fixed。 解决方案：1. position: relative 改为 position: absolute; 2. 去除浮动; 3. 浮动元素添加position属性（如relative，absolute等）。 在写a标签的样式，写的样式没有效果，其实只是写的样式被覆盖了 正确的a标签顺序：link/visited/hover/active 24位png图片，IE6中不兼容透明底儿 解决方式：1. 使用8位png图片; 2. 为ie6准备一套特殊的图片 js在不同浏览器中的兼容问题事件监听的兼容 IE不支持addEventListener; 解决：给IE使用attachEvent 12345678910111213141516171819var addHandler = function(e, type, handler) &#123; if (e.addEventListener) &#123; e.addEventListener(type, handler, false); &#125; else if (e.attachEvent) &#123; e.attachEvent('on' + type, handler); &#125; else &#123; e['on' + type] = handler; &#125;&#125;var removeHandler = function(e, type, handler) &#123; if (e.removeEventListener) &#123; e.removeEventListener(type, handler, false); &#125; else if (e.detachEvent) &#123; e.detachEvent('on' + type, handler); &#125; else &#123; on['on' + type] = null &#125;&#125; event.targey的兼容，引发事件的DOM元素。 IE 6789不支持event.target 解决方法：event.srcElement; 1target = event.target || event.srcElement; 阻止系统默认的兼容 IE 6789不支持event.preventDefault; 1event.preventDefault ? event.preventDefault() : event.returnValue = false 阻止事件冒泡的兼容 IE 6789不支持event.stopPropagation; 1event.stopPropagation ? event.stopPropagation() : event.cancelBubble = false]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[构造方法constructor]]></title>
    <url>%2F2019%2F05%2F03%2F2019%2FMay%2FClasses%2FREADME%2F</url>
    <content type="text"><![CDATA[构造方法constructor是一种用于创建和初始化class创建的对象的特殊方法。描述 在一个类中只能有一个名叫”constructor”的特殊方法。一个类中出现多次将会抛出SyntaxError错误。 在一个构造方法中可以使用super关键字来调用一个父类的构造方法 如果没有显示指定构造方法，则会添加默认的construtor方法。 如果不指定一个构造函数（constructor）方法，则使用一个默认的构造函数（constructor） 如果不指定构造方法，则使用默认构造函数。对于基类，默认构造函数是： 1constructor() &#123;&#125; 对于派生类，默认构造函数是： 123constructor(...args) &#123; super(...args);&#125; extendsextends关键字用于类声明或者类表达式中，以创建一个类，该类是另一个类的子类。描述 extends关键字用来创建一个普通类或者内建对象的子类继承的.prototype必须是一个Object或者null。 static类（class）通过static关键字定义静态方法。不能在类的实例上调用静态方法，而应该通过类本身调用。这些通常是实用程序方法，例如创建或克隆对象的功能 123456class ClassWithStaticMethod &#123; static staticMethod() &#123; return 'static method has been called.'; &#125;&#125;ClassWithStaticMethod.staticMethod(); 调用静态方法 从另一个静态方法，静态方法调用同一个类中的其他静态方法，可使用this关键字 12345678class StaticMethodCall &#123; static staticMethod() &#123; return 'Static method has been called'; &#125; static anotherStaticMethod() &#123; return this.staticMethod() + ' from another static method'; &#125;&#125; 从类的构造函数和其他方法，非静态方法中，不能直接使用this关键字来访问静态方法。而是要用类名来调用；CLASSNAME.STATIC_METHOD_NAME()，或者用构造函数的属性来调用该方法；this.constructor.STATIC_METHOD_NAME()。 1234567891011class StaticMethodCall &#123; constructor() &#123; console.log(StaticMethodCall.staticMethod()); // 'static method has been called.' console.log(this.constructor.staticMethod()); // 'static method has been called.' &#125; static staticMethod() &#123; return 'static method has been called.'; &#125;&#125; 补充 目前ECMAScript，class中还没有定义Private（私有属性）的能力，所以我们通过约定，用下划线来标记它们。 123456789class Car &#123; _milesDriven = 0; drive(distance) &#123; this._milesDriven += distance; &#125; getMilesDriven() &#123; return this._milesDriven; &#125;&#125; 在上面的事例中，我们依靠Car的实例调用getMilesDriven方法来获取到它的私有属性_milesDriven。但是，因为没有什么能使_milesDriven成为私有的，所以任何实例都可以访问它。 123const tesla = new Cal();tesla.drive(10);console.log(tesla._milesDriven); 目前Class Fields有个提案，我们可以通过#创建私有字段。 1234567891011121314class Car &#123; #milesDriven = 0; drive(distance) &#123; this.#milesDriven += distance; &#125; getMilesDriven() &#123; return this.#milesDriven; &#125;&#125;const tesla = new Car()tesla.drive(10)tesla.getMilesDriven() // 10tesla.#milesDriven // Invalid]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[call、apply有什么区别？call、apply和bind的内部实现]]></title>
    <url>%2F2019%2F05%2F01%2F2019%2FMay%2FBind%2FREADME%2F</url>
    <content type="text"><![CDATA[call、apply有什么区别？call、apply和bind的内部实现call、apply的功能相同，区别在于传参的方式不一样： fn.call(obj, arg1, arg2, …)，调用一个函数，具有一个指定的this值和分别提供的参数（参数的列表）。 fn.apply(obj, [argsArray])，调用一个函数，具有一个指定的this值，以及作为一个数组（或类数组对象）提供参数。 call核心 将函数设为传入参数的属性 指定this到函数并传入给定参数执行函数 如果不传入参数或者参数为null，默认指向为 window/global 删除参数上的函数 123456789101112131415161718192021222324252627282930Function.prototype.call = function(context) &#123; /* * 如果第一个参数传入的是 null 或者 undefined，那么this指向 window/global * 如果第一个参数传入的不是 null 或者 undefined，那么必须是一个对象 */ if (!context) &#123; // context为null或者是undefined // 判断是浏览器环境还是node环境 context = typeof window === 'undefined' ? global : window; &#125; context.fn = this; // this指向是当前的函数（Function的实例） let rest = [...arguments].slice(1); // 获取除了this指向对象以外的参数，空数组slice后返回的仍然是空数组 let result = context.fn(...rest); // 隐式绑定，当前函数的this指向了context delete context.fn; return result;&#125;// test codevar foo = &#123; name: 'Selina'&#125;;var name = 'Chirs';function bar(job, age) &#123; console.log(this.name); console.log(job, age);&#125;bar.call(foo, 'programmer', 20);// Selina programmer, 20bar.call(null, 'teacher', 25);// brower环境： Chirs teacher, 25； node环境： undefined teacher, 25 apply核心apply的实现和call很类似，但是需要注意他们的参数不一样，apply的第二个参数是数组或类数组。 123456789101112131415161718192021222324252627282930313233343536Function.prototype.apply = function(context, rest) &#123; /* * 如果第一个参数传入的是 null 或者 undefined，那么this指向 window/global * 如果第一个参数传入的不是 null 或者 undefined，那么必须是一个对象 */ if (!context) &#123; // context为null或者是undefined // 判断是浏览器环境还是node环境 context = typeof window === 'undefined' ? global : window; &#125; context.fn = this; let result; if (rest == null) &#123; // undefined 或者 null 不是 Iterator 对象，不能被... result = context.fn(rest); &#125; else if (typeof rest === 'object') &#123; result = context.fn(...rest); &#125; delete result.fn; return result;&#125;// test codevar foo = &#123; name: 'Selina'&#125;;var name = 'Chirs';function bar(job, age) &#123; console.log(this.name); console.log(job, age);&#125;bar.apply(foo, ['programmer', 20]);// Selina programmer, 20bar.apply(null, ['teacher', 25]);// brower环境： Chirs teacher, 25； node环境： undefined teacher, 25 bind核心bind 和 call/apply 有一个很重要的区别，一个函数被 call/apply 的时候，会直接调用，但是 bind会创建一个新函数。当这个新函数被调用时，bind()的第一个参数将作为它运行时的this，之后的一系列参数将会在传递的实参前传入作为它的参数。 12345678910111213141516171819202122232425Function.prototype.bind = function(context) &#123; if (typeof this !== 'function') &#123; throw new TypeError('not a function'); &#125; let self = this; let args = [...arguments].slice(1); function Fn() &#123;&#125;; Fn.prototype = this.prototype; let bound = function() &#123; let res = [...args, ...arguments]; // bind传递的参数和函数调用时传递的参数拼接 context = this instanceof Fn ? this : context || this; return self.apply(context, res); &#125; // 原型链 bound.prototype = new Fn(); return bound;&#125;var name = 'Jack';function person(age, job, gender)&#123; console.log(this.name , age, job, gender);&#125;var Yve = &#123;name : 'Yvette'&#125;;let result = person.bind(Yve, 22, 'enginner')('female');]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[fileReader读取文件，实现图片本地预览]]></title>
    <url>%2F2018%2F10%2F09%2FfileReader%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[FileReaderFileReader 对象允许Web应用程序异步读取存储在用户计算机上的文件(或原始数据缓冲区)的内容,使用 File 或 Blob 对象指定要读取的文件或数据。 首先创建一个FileReader实例：1var reader = new FileReader(); 方法 方法 描述 abort() 中止读取操作。在返回时，readyState属性为DONE。 readAsArrayBuffer() 开始读取指定的 Blob中的内容, 一旦完成, result 属性中保存的将是被读取文件的 ArrayBuffer 数据对象. readAsBinaryString() 开始读取指定的Blob中的内容。一旦完成，result属性中将包含所读取文件的原始二进制数据。 readAsDataURL() 开始读取指定的Blob中的内容。一旦完成，result属性中将包含一个data: URL格式的字符串以表示所读取文件的内容 readAsText() 开始读取指定的Blob中的内容。一旦完成，result属性中将包含一个字符串以表示所读取的文件内容。 具体事例input file实现本地图片预览123456789var inputBox = document.getElementById(&quot;inputBox&quot;);inputBox.addEventListener(&quot;change&quot;,function()&#123; var reader = new FileReader(); reader.readAsDataURL(inputBox.files[0]);//发起异步请求 reader.onload = function()&#123; // 读取完成后，base64数据保存在对象的result属性中 console.log(this.result) &#125;&#125;) 引用 FileReader详解]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react-router解读（三）]]></title>
    <url>%2F2018%2F08%2F28%2Freact-router%E8%A7%A3%E8%AF%BB%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[history methods createBrowserHistory通过之前我们已经知道了react-router-dom的 history模式使用的是history库中的createBrowserHistory方法。下面我们来一起看看其中的奥秘。 var createBrowserHistory = function createBrowserHistory() { // arguments[0], 由上一节可知它是一个非必传的object var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}; (0, _invariant2.default)(_DOMUtils.canUseDOM, 'Browser history needs a DOM'); // 之前将history赋值给变量globalHistory var globalHistory = window.history; // _DOMUtils.js 中处理一些浏览器兼容性 和 浏览器内核、机型判断的方法 // 判断是否非主流机型以及浏览器 var canUseHistory = (0, _DOMUtils.supportsHistory)(); // 是否为IE浏览器 var needsHashChangeListener = !(0, _DOMUtils.supportsPopStateOnHashChange)(); // forceRefresh为true，代表将在页面导航时使用完整页面刷新。其他参数请自行参考官网文档 var _props$forceRefresh = props.forceRefresh, forceRefresh = _props$forceRefresh === undefined ? false : _props$forceRefresh, _props$getUserConfirm = props.getUserConfirmation, getUserConfirmation = _props$getUserConfirm === undefined ? _DOMUtils.getConfirmation : _props$getUserConfirm, _props$keyLength = props.keyLength, keyLength = _props$keyLength === undefined ? 6 : _props$keyLength; var basename = props.basename ? (0, _PathUtils.stripTrailingSlash)((0, _PathUtils.addLeadingSlash)(props.basename)) : ''; var getDOMLocation = function getDOMLocation(historyState) { var _ref = historyState || {}, key = _ref.key, state = _ref.state; var _window$location = window.location, pathname = _window$location.pathname, search = _window$location.search, hash = _window$location.hash; var path = pathname + search + hash; (0, _warning2.default)(!basename || (0, _PathUtils.hasBasename)(path, basename), 'You are attempting to use a basename on a page whose URL path does not begin ' + 'with the basename. Expected path "' + path + '" to begin with "' + basename + '".'); if (basename) path = (0, _PathUtils.stripBasename)(path, basename); return (0, _LocationUtils.createLocation)(path, state, key); }; var createKey = function createKey() { return Math.random().toString(36).substr(2, keyLength); }; var transitionManager = (0, _createTransitionManager2.default)(); var setState = function setState(nextState) { _extends(history, nextState); history.length = globalHistory.length; transitionManager.notifyListeners(history.location, history.action); }; var handlePopState = function handlePopState(event) { if ((0, _DOMUtils.isExtraneousPopstateEvent)(event)) return; handlePop(getDOMLocation(event.state)); }; var handleHashChange = function handleHashChange() { handlePop(getDOMLocation(getHistoryState())); }; var forceNextPop = false; var handlePop = function handlePop(location) { if (forceNextPop) { forceNextPop = false; setState(); } else { var action = 'POP'; transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) { if (ok) { setState({ action: action, location: location }); } else { revertPop(location); } }); } }; var revertPop = function revertPop(fromLocation) { var toLocation = history.location; // TODO: We could probably make this more reliable by // keeping a list of keys we've seen in sessionStorage. // Instead, we just default to 0 for keys we don't know. var toIndex = allKeys.indexOf(toLocation.key); if (toIndex === -1) toIndex = 0; var fromIndex = allKeys.indexOf(fromLocation.key); if (fromIndex === -1) fromIndex = 0; var delta = toIndex - fromIndex; if (delta) { forceNextPop = true; go(delta); } }; var initialLocation = getDOMLocation(getHistoryState()); var allKeys = [initialLocation.key]; var createHref = function createHref(location) { return basename + (0, _PathUtils.createPath)(location); }; var push = function push(path, state) { (0, _warning2.default)(!((typeof path === 'undefined' ? 'undefined' : _typeof(path)) === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to push when the 1st ' + 'argument is a location-like object that already has state; it is ignored'); var action = 'PUSH'; // 重写location对象 var location = (0, _LocationUtils.createLocation)(path, state, createKey(), history.location); transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) { if (!ok) return; var href = createHref(location); var key = location.key, state = location.state; if (canUseHistory) { globalHistory.pushState({ key: key, state: state }, null, href); if (forceRefresh) { window.location.href = href; } else { var prevIndex = allKeys.indexOf(history.location.key); var nextKeys = allKeys.slice(0, prevIndex === -1 ? 0 : prevIndex + 1); nextKeys.push(location.key); allKeys = nextKeys; setState({ action: action, location: location }); } } else { (0, _warning2.default)(state === undefined, 'Browser history cannot push state in browsers that do not support HTML5 history'); window.location.href = href; } }); }; var replace = function replace(path, state) { (0, _warning2.default)(!((typeof path === 'undefined' ? 'undefined' : _typeof(path)) === 'object' && path.state !== undefined && state !== undefined), 'You should avoid providing a 2nd state argument to replace when the 1st ' + 'argument is a location-like object that already has state; it is ignored'); var action = 'REPLACE'; var location = (0, _LocationUtils.createLocation)(path, state, createKey(), history.location); transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) { if (!ok) return; var href = createHref(location); var key = location.key, state = location.state; if (canUseHistory) { globalHistory.replaceState({ key: key, state: state }, null, href); if (forceRefresh) { window.location.replace(href); } else { var prevIndex = allKeys.indexOf(history.location.key); if (prevIndex !== -1) allKeys[prevIndex] = location.key; setState({ action: action, location: location }); } } else { (0, _warning2.default)(state === undefined, 'Browser history cannot replace state in browsers that do not support HTML5 history'); window.location.replace(href); } }); }; var go = function go(n) { globalHistory.go(n); }; var goBack = function goBack() { return go(-1); }; var goForward = function goForward() { return go(1); }; var listenerCount = 0; var checkDOMListeners = function checkDOMListeners(delta) { listenerCount += delta; if (listenerCount === 1) { (0, _DOMUtils.addEventListener)(window, PopStateEvent, handlePopState); if (needsHashChangeListener) (0, _DOMUtils.addEventListener)(window, HashChangeEvent, handleHashChange); } else if (listenerCount === 0) { (0, _DOMUtils.removeEventListener)(window, PopStateEvent, handlePopState); if (needsHashChangeListener) (0, _DOMUtils.removeEventListener)(window, HashChangeEvent, handleHashChange); } }; var isBlocked = false; var block = function block() { var prompt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false; var unblock = transitionManager.setPrompt(prompt); if (!isBlocked) { checkDOMListeners(1); isBlocked = true; } return function () { if (isBlocked) { isBlocked = false; checkDOMListeners(-1); } return unblock(); }; }; var listen = function listen(listener) { var unlisten = transitionManager.appendListener(listener); checkDOMListeners(1); return function () { checkDOMListeners(-1); unlisten(); }; }; var history = { length: globalHistory.length, action: 'POP', location: initialLocation, createHref: createHref, push: push, replace: replace, go: go, goBack: goBack, goForward: goForward, block: block, listen: listen }; return history; };]]></content>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react-router解读（二）]]></title>
    <url>%2F2018%2F08%2F27%2Freact-router%E8%A7%A3%E8%AF%BB%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[react-router 的路由实现既然知道了这个原理，我们来看下 react-router 的实现，我们打开 react-router 项目地址,把项目克隆下来，或则直接在 github 上预览，在 React 开发的项目里，我们通过 router.push(‘home’) 来实现页面的跳转，所以我们检索下，push 方法的实现 我们检索到了 46个 js 文件，😂，一般到这个时候，我们会放弃源码阅读，那么我们今天的文章就到这结束，谢谢大家！ 开个玩笑，源码阅读不能这么粗糙，react-router 4.x用法，我们只需要安装 react-router-dom。所以我们找到 package 下的 react-router-dom/modules 目录，点开 index.js 文件。 export BrowserRouter from "./BrowserRouter"; export HashRouter from "./HashRouter"; export Link from "./Link"; export MemoryRouter from "./MemoryRouter"; export NavLink from "./NavLink"; export Prompt from "./Prompt"; export Redirect from "./Redirect"; export Route from "./Route"; export Router from "./Router"; export StaticRouter from "./StaticRouter"; export Switch from "./Switch"; export generatePath from "./generatePath"; export matchPath from "./matchPath"; export withRouter from "./withRouter"; 看到 history 对象的实例与配置的 mode 有关，react-router-dom 通过3种方式实现了路由切换。我们今天讲的内容相匹配的是 createBrowserHistory 的实现方案 (另外两个分别是：createHashHistory和createMemoryHistory)。 这里 react-router-dom 将 BrowserRouter、HashRouter、Link 拆分为单独组件实现，也是与 react-router 3 之间的区别之一。详细文档我们来看 react-router-dom 中的 BrowserRouter 源码： import warning from "warning"; import React from "react"; import PropTypes from "prop-types"; import { createBrowserHistory as createHistory } from "history"; import Router from "./Router"; /** * The public API for a that uses HTML5 history. */ class BrowserRouter extends React.Component { static propTypes = { basename: PropTypes.string, forceRefresh: PropTypes.bool, getUserConfirmation: PropTypes.func, keyLength: PropTypes.number, children: PropTypes.node }; history = createHistory(this.props); componentWillMount() { warning( !this.props.history, " ignores the history prop. To use a custom history, " + "use `import { Router }` instead of `import { BrowserRouter as Router }`." ); } render() { return ; } } export default BrowserRouter; 由上可知我们在项目中使用的组件，history方式是使用了一个叫history库中的 createBrowserHistory 方法。 模拟单页面路由通过上面的学习，我们知道了，单页面应用路由的实现原理，我们也尝试去实现一个。在做管理系统的时候，我们通常会在页面的左侧放置一个固定的导航 sidebar，页面的右侧放与之匹配的内容 main 。点击导航时，我们只希望内容进行更新，如果刷新了整个页面，到时导航和通用的头部底部也进行重绘重排的话，十分浪费资源，体验也会不好。这个时候，我们就能用到我们今天学习到的内容，通过使用 HTML5 的 pushState 方法和 replaceState 方法来实现， 思路：首先绑定 click 事件。当用户点击一个链接时，通过 preventDefault 函数防止默认的行为（页面跳转），同时读取链接的地址（如果有 jQuery，可以写成$(this).attr(‘href’)），把这个地址通过pushState塞入浏览器历史记录中，再利用 AJAX 技术拉取（如果有 jQuery，可以使用$.get方法）这个地址中真正的内容，同时替换当前网页的内容。 为了处理用户前进、后退，我们监听 popstate 事件。当用户点击前进或后退按钮时，浏览器地址自动被转换成相应的地址，同时popstate事件发生。在事件处理函数中，我们根据当前的地址抓取相应的内容，然后利用 AJAX 拉取这个地址的真正内容，呈现，即可。 最后，整个过程是不会改变页面标题的，可以通过直接对 document.title 赋值来更改页面标题。 扩展好了,我们今天通过多个方面来讲了 pushState 方法和 replaceState 的应用，你应该对这个两个方法能有一个比较深刻的印象，如果想要了解更多，你可以参考以下链接 history对象]]></content>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react-router解读（一）]]></title>
    <url>%2F2018%2F08%2F27%2Freact-router%E8%A7%A3%E8%AF%BB%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前言前端路由是通过改变URL，在不重新请求页面的情况下，更新页面视图。目前在浏览器环境中这一功能的实现主要有2种: 利用URL中的hash 利用H5中history pushState 和 replaceState 了解一下 history 提供了两个方法，能够无刷新的修改用户的浏览记录，pushSate，和 replaceState，区别的 pushState 在用户访问页面后面添加一个访问记录， replaceState 则是直接替换了当前访问记录 history 对象的详细信息已经有很多很好很详细的介绍文献，这里不再做总结history对象 history.pushStatehistory.pushState方法接受三个参数，依次为： state：一个与指定网址相关的状态对象，popstate事件触发时，该对象会传入回调函数。如果不需要这个对象，此处可以填null。title：新页面的标题，但是所有浏览器目前都忽略这个值，因此这里可以填null。url：新的网址，必须与当前页面处在同一个域。浏览器的地址栏将显示这个网址。假定当前网址是example.com/1.html，我们使用pushState方法在浏览记录（history对象）中添加一个新记录。 var stateObj = { foo: 'bar' }; history.pushState(stateObj, 'page 2', '2.html'); 添加上面这个新记录后，浏览器地址栏立刻显示 example.com/2.html，但并不会跳转到 2.html，甚至也不会检查2.html 是否存在，它只是成为浏览历史中的最新记录。这时，你在地址栏输入一个新的地址(比如访问 google.com )，然后点击了倒退按钮，页面的 URL 将显示 2.html；你再点击一次倒退按钮，URL 将显示 1.html。 总之，pushState 方法不会触发页面刷新，只是导致 history 对象发生变化，地址栏会有反应。 如果 pushState 的 url参数，设置了一个新的锚点值（即hash），并不会触发 hashchange 事件。如果设置了一个跨域网址，则会报错。 // 报错 history.pushState(null, null, 'https://twitter.com/hello'); 上面代码中，pushState想要插入一个跨域的网址，导致报错。这样设计的目的是，防止恶意代码让用户以为他们是在另一个网站上。 history.replaceStatehistory.replaceState 方法的参数与 pushState 方法一模一样，区别是它修改浏览历史中当前纪录,假定当前网页是 example.com/example.html。 history.pushState({page: 1}, 'title 1', '?page=1'); history.pushState({page: 2}, 'title 2', '?page=2'); history.replaceState({page: 3}, 'title 3', '?page=3'); history.back() // url显示为http://example.com/example.html?page=1 history.back() // url显示为http://example.com/example.html history.go(2) // url显示为http://example.com/example.html?page=3]]></content>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello Hexo]]></title>
    <url>%2F2018%2F08%2F24%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
